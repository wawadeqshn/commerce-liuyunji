{
    "status": "0",
    "data": [
        {
            "_id": "65390af45cdc0333f4241411",
            "Title": "肉苁蓉",
            "order": "",
            "Summary": "常见的数据映射处理，有用的",
            "Content": "## 一：题目：\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n- 字符          数值\n- I             1\n- V             5\n- X             10\n- L             50\n- C             100\n- D             500\n- M             1000\n\n例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。\n\n## 二：解题\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    let simple = {\n        I: 1,\n        V: 5,\n        X: 10,\n        L: 50,\n        C: 100,\n        D: 500,\n        M: 1000\n    }\n    let special = {\n        IV: 4,\n        IX: 9,\n        XL: 40,\n        XC: 90,\n        CD: 400,\n        CM: 900\n    }\n    let num = 0;\n    \n    // 删掉字符串中特殊的6种组合\n    for(i in special){\n        if(s.indexOf(i) >= 0){\n            num += special[i];\n            s = s.replace(i,\"\");\n        }\n    }\n\n    // 将剩下的简单字符串分割为数组，直接转义相加\n    let simpleArr = s.split(\"\");\n    simpleArr.forEach((item)=>{\n        num += simple[item];\n    });\n    \n    return num;\n};\n```\n## 三：总结\n#### 1、使用场景\n\n本题目个人理解是完成对字符的映射转换，在日常开发中也经常遇见。比如，数据库拿到的数据都是一堆数字，需要根据映射规则转换成文本。感觉练习练习还是有用的\n#### 2、思路\n规则分为简单规则和特殊规则，简单规则如代码中simple直接相加即可，特殊规则如变量special。\n先将两种映射关系用对象写好，然后删除掉特殊规则的字符，并将映射的数字相加，最终将剩下的字符串转成简单规则直接相加即可。",
            "CreateDate": "2023-10-25T12:24:03.055Z",
            "ArticleTag": "算法",
            "ArticleCover": "http://39.104.22.73:8888/likou.jpg",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTY5NTYzMTg2MCwiZXhwIjozNjAwfQ==.eHCcq5SoE4iQ55eklQ9sVlKRkNw47i4ZYMYReI1WkR8=",
            "CommentNum": 9,
            "articleReadNum": 997
        },
        {
            "_id": "6514ddd35cdc0333f4240383",
            "Title": "黑枸杞",
            "order": "",
            "Summary": "使用数组的笨方法解决，但是有收获",
            "Content": "## 一：题目：\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n \n\n示例 1：\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n## 二：解题\n\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function(head) {\n    let arr = [];\n    let cur = head;\n    while(cur){\n        arr.push(cur);\n        cur = cur.next;\n    }\n\n    let result = new ListNode(null);\n    let l = result; // 头节点，代表整体链表\n    while(arr.length > 0){ \n        let item = arr.pop();  // 直接用pop来巧用栈\n        result.next = new ListNode(item.val);\n        result = result.next;\n    }\n    return l.next;\n};\n\n```\n## 三：总结\n### 1、传说中的用栈解决\n\n平时有看到别人说用栈的方法解决，意思其实就是巧用数组的pop方法。\n\n可以避免先翻转数据，再for循环。拓展了这个解题思路以后都可以用先进后出啦\n\n### 2、头节点的特殊含义\n\n头节点本身确实只是一个普通的节点，和链表中的其他节点没有区。但是，由于头节点是链表的起始节点，因此它具有特殊的意义，**我们通常将它用作链表的引用**，以便于访问整个链表。在许多链表操作中，我们需要修改链表的结构或遍历整个链表，这些操作基本上需要从头节点开始，不是单独的一个节点，而是一个取得访问整个链表权限的节点。\n\n因此，在算法或问题上下文中，我们经常会将头节点描述为整个链表的引用，意味着访问整个链表所需要的入口点和起点。这种描述方式并没有将头节点与其他节点区别开来，只不过赋予了头节点特定的角色和功能，以使我们更方地操作链表。\n\n所以代码中要用一个临时变量存下头节点，它能代表整个链表。如果不这么操作，直接\n```\nreturn result.next \n```\n会返回最后一个节点的下个节点，null，而不是整个链表",
            "CreateDate": "2023-09-28T01:48:52.104Z",
            "ArticleTag": "算法",
            "ArticleCover": "http://39.104.22.73:8888/likou.jpg",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTY5NTYzMTg2MCwiZXhwIjozNjAwfQ==.eHCcq5SoE4iQ55eklQ9sVlKRkNw47i4ZYMYReI1WkR8=",
            "CommentNum": 2,
            "articleReadNum": 367
        },
        {
            "_id": "64e75e416cece15fa7beba48",
            "Title": "覆盆子",
            "order": "",
            "Summary": "初次体验到数据库查询语言的效率之高",
            "Content": "## 一：需求场景\n我的个人网站留言列表在开发时，因为本着先有功能的原则。留言列表只有一级，平铺的。\n\n当涉及多人回复，或者两个人多次对话后， 留言逻辑看着非常混乱。如下图\n![](https://pic1.zhimg.com/80/v2-bde199904510923fdd49455a692ec14c_720w.webp)\n\n\n于是，我就打算将平铺的列表，改造为二级列表。效果图如下\n![](https://pic2.zhimg.com/80/v2-d52248e70a3a2fc22e19be68a8c9d589_1440w.webp)\n\n## 二：实现方案\n因为我是前端开发，对数据库查询语言的认知还停留在\n```\nselect * from table\n```\n我对数据库的使用，之前真真就是把它当个持久存放数据的仓库。查询语句都停留在最简单的增删改查。\n\n于是我在考虑如何实现功能时，第一个想法又是，在原有表结构的基础上添加一个parent字段。\n\n如果是顶级留言parent字段存放空值，二级或者三级都存放父级的id。\n\n然后接口返回数据给前端，前端JS再把数据处理两级的结构。虽然个人网站的前后端都是我自己。但是还是感觉JS更加顺手\n\n后来考虑到存在分页，如上方案是解决不了分页问题的。\n\n## 三： 数据库查询语句\n因为后端是用Node.js配合MongoDB开发的，于是去查了查用Mongodb的查询语句直接完成两级结构。\n\n然后我打开了一个新世界的大门～～～\n\n数据库的查询语句可比JS在哪处理数据的效率高上几个维度，如下为使用Mongodb的管道聚合的查询语句。一个语句搞定JS无数个循环，且逻辑清晰！\n```\nDB.collection(Collection).aggregate([\n    {\n        $sort: {\n            _id: -1 // 先按时间倒序排序\n        }\n    },\n    {\n        $lookup: { // 将子留言与其父级文档关联，将自留言的集合作为父留言的一个字段\n            from: Collection,\n            localField: \"_id\",\n            foreignField: \"parentId\",\n            as: \"son\"\n        }\n    },\n    {\n        $match: { // 只留下顶级评论\n            parentId: { $in: [\"\", null] }\n        }\n    },\n    {\n        $skip: data.Skip // 跳过(page-1)*page_size条文档数，供分页使用\n    }, \n    {\n        $limit: data.Limit// 限制返回的文档数为page_size，供分页使用\n    }\n\n])\n```\n## 四：Mongodb的管道聚合\nMongodb中管道通常由多个阶段构成，每个阶段由一个操作和它的参数组成，如 $match、$project、$sort、$group 等。\n\n这些阶段按照代码书写顺序执行，每一个阶段输出都是它下一个阶段的输入，所有阶段的输出结果最终形成管道的最终输出。",
            "CreateDate": "2023-08-24T13:15:58.988Z",
            "ArticleTag": "后端语言",
            "ArticleCover": "http://39.104.22.73:8888/mongo.jpeg",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTY2Mjk4Njk4MSwiZXhwIjozNjAwfQ==.8RDURh3uLa8uai3G2XNYVED3IDdFh4iEqdwhepBS8+Q=",
            "CommentNum": 15,
            "articleReadNum": 676
        },
        {
            "_id": "64b413df24d1243de00864a8",
            "Title": "淫羊藿",
            "order": "",
            "Summary": "本博客基于Nuxt的重构版本，采用服务端渲染方式，旨在提升SEO。已开始自测，灰度地址为http://39.104.22.73",
            "Content": "​\n我的个人网站是用vuecli写的，SEO不忍直视。于是用Nuxt重构了代码，其实网上相关资料并不多，过程中踩了无数坑，记录如下\n\n## 一：body样式不生效\n正常的body样式设置不能生效，需要在nuxt.config.js中配置\n\n1、设置bodyAttrs的class属性，该属性值对应一个类名\n\n2、该类名所在的css文件，需要在nuxt.config.js中设置一下路径\n![](https://pic3.zhimg.com/80/v2-effb4852ed5b818dfbd4d352f1fc04b6_1440w.webp)\n\n## 二：store的用法差异\n声明时差异：export出一个函数\n![](https://pic4.zhimg.com/80/v2-b1b69186acff610efe350676577100e7_1440w.webp)\n\n\n 调用时差异：import的是个函数，所以要先执行函数\n![](https://pic1.zhimg.com/80/v2-e6f9ec37c6b4bc236128075e420ba96c_1440w.webp)\n\n\n## 三：Nuxt打包\nNuxt打包分为两种，一种是打成静态页面，一种是以SSR的形式打包。\n\n1、打成静态页面\n如果需要打包成静态资源，需要执行npm run generate\n\n且nuxt.config.js需要做如下配置\n![](https://pic3.zhimg.com/80/v2-9cdcd44be580f5d35e0c3501c746efee_1440w.webp)\n\n\n2、SSR打包\nnpm run build\n\n## 四：Nuxt的Vuex使用\n在plugins文件夹下，放一个vuex.js文件，并在nuxt.config.js中引入。\n\n然后在store文件夹下管理状态才能正常使用\n\n![](https://pic3.zhimg.com/80/v2-c6d29560ee3097a6590633eb5b63b8de_1440w.webp)\n\n![](https://pic1.zhimg.com/80/v2-6c35b95c8ec6ff9ac12c75c33dabc8fc_1440w.webp)\n\n## 五：引入iconfont\n只需要将iconfont的资源文件放在assets文件夹下，然后在nuxt.config.js的css属性写上地址即可\n\n![](https://pic3.zhimg.com/80/v2-05cc3315e44aaba22c779120b3e309ae_1440w.webp)\n\n## 六：引入axios报错\n报错信息如下\n\n\n大概意思是vue-server-renderer需要commonJS规范的组件，但是axios是ES6规范的组件，不能用。后来降低了axios版本后不再报错，版本号为axios@0.18.0。可能是因为老版本用的commonJS规范\n\n## 七：Nuxt配置本地代理\n\n1、在 Nuxt.js 项目的根目录下创建一个名为 middleware 的文件夹（如果已存在则跳过此步骤）。\n\n2、在 middleware 文件夹中创建一个名为 proxy.js 的文件，并添加以下代码：\n```\nconst { createProxyMiddleware } = require('http-proxy-middleware')\nmodule.exports = function (req, res, next) {\n  if (req.url.startsWith('/api')) {\n    // 将请求代理到目标地址\n    createProxyMiddleware('/api', { \n      target: 'http://39.104.22.73:8888/', \n      changeOrigin: true,\n      pathRewrite: {\n        '^/api': '' //路径重写\n      },\n      pathRequiresRewrite: {\n        '^/api': ''\n      }\n  })(req, res, next)\n  } else {\n    next()\n  }\n}\n```\n打开 nuxt.config.js 文件，将以下代码添加到 serverMiddleware 配置项中：\n```\nserverMiddleware: [\n  '~/middleware/proxy'\n],\n```\n重启项目后，以 /api 开头的请求将被代理到 http://api.example.com。\n\n\n## 八：Nuxt2使用echarts5\nNuxt引入echarts有两种方式，\n\n使用Nuxt的echarts然后配置\n直接安装，正常引入即可\n我直接使用的第二种，但是引入echarts5时报错。报错Unexpected token export\n\n通常是由于Nuxt.js默认使用的是CommonJS模块系统，而ECharts 5使用ES模块语法所致。需要对ECharts 5的ES模块语法进行转译。\n\n为了解决这个问题，你可以尝试以下方法：\n```\n在nuxt.config.js中设置\n\n  build: {\n    transpile: [/echarts/, /zrender/]\n  },\n```\n其中zrender为echarts依赖的底层组件，注意填写，否则可能无法生效。\n\n配置之后，Nuxt会自动对ES模块进行转义，无需对转义进行额外配置，这个还是很方便的\n\n## 九：Nuxt到底能做多少SEO优化？\n通过Nuxt配置，即使使用了SSR模式，打包后的静态网站在浏览器的Sources面板中仍然无法看到完整的网页内容。这是因为Nuxt.js默认情况下在生成静态文件时只包含首页的DOM结构，其他页面的DOM结构在浏览器中通过客户端渲染动态生成。\n\nNuxt.js通过服务器端渲染（SSR）模式来解决一些SEO问题，但并不能完全解决所有SEO问题。\n\n如下为使用Nuxt打包成静态页面前后，网站sources面板看到的html\n![](https://pic2.zhimg.com/80/v2-a2f16ebe0e749f9a34594082f162ea1d_1440w.webp)\n\n[未使用Nuxt generate前的Source]\n![](https://pic2.zhimg.com/80/v2-18f3191f65be117e1be87ce02bc51a15_1440w.webp)\n[使用Nuxt generate后的source]\nNuxt 打包成静态页面后，对SEO优化没实质性改善。以SSR打包后，效果会好一些\n\n如下为chatGPT对SSR打包模式的讲解：\n\n> 虽然在浏览器的\"Sources\"面板中无法直接看到完整的HTML代码，但搜索引擎爬虫通常可以爬取到Nuxt.js打包的静态网站的完整HTML内容。\n当使用Nuxt.js进行服务器端渲染（SSR）并生成静态网站时，每个路由都会被预先生成为一个HTML文件。这些HTML文件包含了相应路由页面的完整静态内容，包括初始化数据、组件内容以及其他相关资源。\n搜索引擎的爬虫会模拟浏览器的行为，发送HTTP请求并获取网页内容，爬取到的内容也包括完整的HTML。它们可以处理JavaScript渲染，并从静态HTML中获取页面内容来进行索引。\n因此，尽管在浏览器的\"Sources\"面板中我们无法直接查看到完整的HTML代码，但搜索引擎爬虫通常可以正确抓取和索引由Nuxt.js生成的静态网站的完整HTML内容。\n\n\n\n 暂且相信它一次，我把Nuxt重构后的代码部署到Nginx上，看看年底百度能不能收录到我的网站。到时候再把结果公布到这里\n\n## 十：部署到Nginx\n1. 部署SSR模式包\n\nSSR模式，在本地npm run build后。将如下文件上传到nginx的html目录下\n![](https://pic4.zhimg.com/80/v2-2f003ccf2e6a5289b4fb184f04a2a32b_1440w.webp)\n注意Nuxt跟vue-cli是不同的，Nuxt除了.nuxt目录还要上传另外几个文件。然后在nuxt.config.js同级路径下执行，npm install，npm run start。这时服务器的3000端口就跑起了咱的应用\n\n然后，我们需要配置代理，将你需要的端口号（比如80）代理到3000端口上即可 \n\n具体就是在nginx.conf里面location中这样配置即可\n```\nserver {\n        listen       80 default_server;\n        listen       [::]:80 default_server;\n        server_name  _;\n        #root         /usr/share/nginx/html/sqblog/.nuxt/dist/client;\n        index index.html;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n\n        location / {\n                proxy_pass http://localhost:3000;               proxy_set_header Host $host;\n                proxy_http_version 1.1;\n                proxy_set_header Upgrade $http_upgrade;\n                proxy_set_header Connection \"upgrade\";\n                proxy_set_header X-Real-IP $remote_addr;\n        }\n}\n```\n2. 部署静态页面模式网页\n\n相对来说以这种模式打包，部署起来相对简单些。直接单独将dist文件夹上传到Nginx的html路径下即可，无序而外文件。\n\n主要问题一般出在文件读取权限上，即访问时报404。\n\n具体解决办法可以问chatgpt，先创建用户与用户组，然后将文件归属该用户组，最后给文件赋权限即可。\n\n静态网页上传到Nginx的html目录下，依旧需要配置nginx.conf\n\n 如果你想将静态网页放在nginx的html的dist文件夹下，并希望在URL的某个端口号后不需要写dist就可以打开页面，你可以尝试使用rewrite规则来实现。如果你希望在不同的端口号上对应不同的文件夹，可以在nginx的配置文件中添加多个server块，每个块指定不同的端口号和对应的文件夹路径。以下是一个示例配置：\n```\nserver {\n  listen 8080;\n  root /path/to/nginx/html/dist1;\n  index index.html;\n  location / {\n    try_files $uri $uri/ /index.html;\n  }\n}\n\nserver {\n  listen 8081;\n  root /path/to/nginx/html/dist2;\n  index index.html;\n  location / {\n    try_files $uri $uri/ /index.html;\n  }\n}\n```\n如下为设置post请求代理：\n\n要在Nginx中配置静态网页的POST请求代理，你可以使用proxy_pass指令来将POST请求反向代理到另一个服务器或应用程序。其实就是在上面配置的server模块中，再加一个location。\n\n以下是一个示例配置：\n```\nserver {\n  listen 80;\n  server_name example.com;\n  location / {\n    root /path/to/your/static/files;\n    try_files $uri $uri/ =404;\n  }\n  location /api {\n    rewrite ^/api(.*)$ $1 break;\n    proxy_pass http://backend_server;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  }\n}\n```\n上面示例中，在location /api块中添加了一个rewrite指令。这个指令会把请求URL中的/api前缀去掉，并把剩余部分作为反向代理的路径。\n\n这样，如果你的静态网站中的POST请求以/api开头，Nginx将会代理这些请求至后端服务器，并将响应返回给客户端。URL中的/api前缀将被移除，后端服务器收到的请求将是不带前缀的形式。\n\n代理转发后的效果如下：\n\n// 浏览器看到的请求\nhttp://39.104.22.73/api/getarticlenum/foreend\n\n// 代理后实际的请求；\nhttp://39.104.22.73:8888/getarticlenum/foreend\n## 十一：部署后的启动\n关于启动服务\n\n直接npm run start，坚持没几分钟服务就挂了。可以使用forever获得持久的服务\n```\nforever start -c \"npm run start\" ./\n```\n关于代码更新后，重启服务。首先干掉之前的进程\n```\nsudo lsof -i :3000\n```\n上述命令将显示占用端口 3000 的进程的详细信息，包括 PID（进程ID）。你需要记下该 PID，然后使用以下命令终止该进程：\n```\nkill <PID>\n```\n然后重新执行，npm run start\n\n最后重启forever工具\n```\nforever restartall\n```\n​",
            "CreateDate": "2023-07-16T15:51:20.554Z",
            "ArticleTag": "前端开发",
            "ArticleCover": "http://39.104.22.73:8888/mylife.jpg",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTY2Mjk4Njk4MSwiZXhwIjozNjAwfQ==.8RDURh3uLa8uai3G2XNYVED3IDdFh4iEqdwhepBS8+Q=",
            "CommentNum": 11,
            "articleReadNum": 567
        },
        {
            "_id": "64ae077aa90eae6f08b90eed",
            "Title": "Nginx安装与基础部署",
            "order": "",
            "Summary": "由手搓node服务到使用Nginx之路，只适合小白起步得分享笔记~",
            "Content": "​\n我的个人网站以前都是自己写一个node文件，直接起个服务当服务器了。后来感觉还是得正式点，慢慢得都转到Nginx上。于是开始了Nginx摸索之旅\n\n## 一：安装\n安装方式有多种，每种方式的繁琐程度不同\n\n使用系统包管理器安装\n使用源码编译安装\n其中，使用系统包管理器安装如沐春风，使用源码编译安装味同嚼蜡。所以我只说用系统包管理器安装\n\n#### 1、使用系统包管理器安装（CentOS系统）\n```\n// 安装\nyum install epel-release\nyum install nginx\n\n// 启动\nsudo systemctl start nginx\n\n```\n\n\n#### 2、一些默认路径\nNginx的网站文件存放在/etc/nginx/sites-available目录下，\n默认的静态网页文件夹是/usr/share/nginx/html目录\n配置文件通常位于/etc/nginx目录下。具体的文件名可能是nginx.conf\n查看Nginx的错误日志，通常位于 /var/log/nginx/error.log\n#### 3、设置html文件夹权限\n直接用sftp上传文件到linux的html文件下 ，会报权限拒绝\n\n可以先给html赋777权限，然后重启Linux\n```\n// 赋777权限\nsudo chmod -R 777 /usr/share/nginx/html\n\n// 重启\nsudo service nginx reload\n```\n## 二：配置\n#### 1、隐藏某级路径\n如果你想将静态网页放在nginx的html的dist文件夹下，并希望在URL的某个端口号后不需要写dist就可以打开页面，你可以尝试使用rewrite规则来实现。如果你希望在不同的端口号上对应不同的文件夹，可以在nginx的配置文件中添加多个server块，每个块指定不同的端口号和对应的文件夹路径。以下是一个示例配置：\n```\nserver {\n  listen 8080;\n  root /path/to/nginx/html/dist1;\n  index index.html;\n  location / {\n    try_files $uri $uri/ /index.html;\n  }\n}\n\nserver {\n  listen 8081;\n  root /path/to/nginx/html/dist2;\n  index index.html;\n  location / {\n    try_files $uri $uri/ /index.html;\n  }\n}\n```\n#### 2、设置post请求代理\n要在Nginx中配置静态网页的POST请求代理，你可以使用proxy_pass指令来将POST请求反向代理到另一个服务器或应用程序。其实就是在上面配置的server模块中，再加一个location。\n\n以下是一个示例配置：\n```\nserver {\n  listen 80;\n  server_name example.com;\n  location / {\n    root /path/to/your/static/files;\n    try_files $uri $uri/ =404;\n  }\n  location /api {\n    rewrite ^/api(.*)$ $1 break;\n    proxy_pass http://backend_server;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  }\n}\n```\n上面示例中，在location /api块中添加了一个rewrite指令。这个指令会把请求URL中的/api前缀去掉，并把剩余部分作为反向代理的路径。\n\n这样，如果你的静态网站中的POST请求以/api开头，Nginx将会代理这些请求至后端服务器，并将响应返回给客户端。URL中的/api前缀将被移除，后端服务器收到的请求将是不带前缀的形式。\n\n代理转发后的效果如下：\n```\n// 浏览器看到的请求\nhttp://39.104.22.73/api/getarticlenum/foreend\n\n// 代理后实际的请求；\nhttp://39.104.22.73:8888/getarticlenum/foreend\n```\n​",
            "CreateDate": "2023-07-12T01:49:13.486Z",
            "ArticleTag": "服务器部署",
            "ArticleCover": "http://39.104.22.73:8888/blogStudy.jpeg",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTY4NzgzNzUxOSwiZXhwIjozNjAwfQ==.xNfVRVJXVrCqRc/E2LFuOoW0h6mCmF8279Ktk8msSU4=",
            "CommentNum": 6,
            "articleReadNum": 340
        },
        {
            "_id": "6441188a02f92d1138bcb2a5",
            "Title": "天气预报功能",
            "order": "",
            "Summary": "平时经常百度天气情况，于是给自己的博客做了一个获取天气预报的功能",
            "Content": "平时经常百度天气情况，于是给自己的博客做了一个获取天气预报的功能\n\n大体步骤是先配置高德地图，申请一个服务编码。然后先调用高德的定位接口获取用户所在城市，在根据城市去查天气预报接口获得数据；\n\n## 一：配置高德地图\n先访问高德官网：高德控制台，注册后申请应用，获取key值。\n\n这个key值可以通用高德提供的所有服务接口，比如定位、天气、路线规划、关键字搜索等。\n![高德控制台](https://pic2.zhimg.com/v2-be1c403d6e880f9828f3f3b0eb33be0d_r.jpg)\n\n\n## 二：访问接口\n### 1、具体接口文档如下：\n定位接口：[IP定位-API文档| 高德地图API](https://lbs.amap.com/api/webservice/guide/api/ipconfig/)\n\n天气预报接口：[天气查询-API文档 | 高德地图API](https://lbs.amap.com/api/webservice/guide/api/weatherinfo)\n\n### 2、代码实现较简单，大致如下\n```\nGetLocation(getWeathData)；\n \nfunction GetLocation(func) {\n    let that = this,\n      locationCookie = this.getSQCookie('sunqBlogLocation'),\n      sunqBlogLocationCode = this.getSQCookie('sunqBlogLocationCode');\n \n    // 如果用户多次访问，一周内不会重复请求定位接口\n    if(locationCookie){\n      func(locationCookie,sunqBlogLocationCode);\n    }else {\n      axios({\n        url: 'https://restapi.amap.com/v3/ip',\n        method: 'post',\n        params: {\n          key: 'ba5f9b69f0541123a4dbe142da230b4d'\n        },\n      }).then(function (resp) {\n        func(resp.data.city,resp.data.adcode);\n        that.setSQCookie('sunqBlogLocation',resp.data.city,3); // 相隔3小时同一浏览器再次访问时会重新定位\n        that.setSQCookie('sunqBlogLocationCode',resp.data.adcode,3);\n      }).catch();\n    }\n  };\n \nfunction getWeathData(cityName, cityCode) {\n      let that = this;\n      axios({\n        url: \"https://restapi.amap.com/v3/weather/weatherInfo\",\n        method: \"GET\",\n        params: {\n          key: \"ba5f9b69f0541123a4dbe142da230b4d\",\n          city: cityCode,\n          extensions: 'all',\n          output: \"JSON\"\n        },\n      }).then(function (resp) {\n          //  此处获得天气预报数据\n          console.log(resp.data);\n \n          that.setSQCookie(\n            \"sunqBlogWeather\",\n            resp.data,\n            3\n          ); // 相隔3小时同一浏览器再次访问时会重新获取天气\n        })\n        .catch();\n    }\n```\n## 三：效果演示\n留言页面：右下方组件\n\n详细代码：[Github地址](https://github.com/SunQQQ/SunQBlog-UserSide)\n",
            "CreateDate": "2023-04-20T10:41:48.830Z",
            "ArticleTag": "前端开发",
            "ArticleCover": "http://39.104.22.73:8888/wheath.png",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTY4MTM3NzA1MiwiZXhwIjozNjAwfQ==.JcdTpjaHhu1Xp81HiAjZMOA6QU1TjDDw+uw/hVQbEc8=",
            "CommentNum": 7,
            "articleReadNum": 1593
        },
        {
            "_id": "6441165602f92d1138bcb29d",
            "Title": "邮件提醒（node.js）",
            "order": "",
            "Summary": "游客在留言板留言后，我会同步收到邮件。是这样实现的...",
            "Content": "​\n以前看别人博客留言或者评论文章时必须填写邮箱信息，感觉甚是麻烦。\n\n后来才知道是为了在博主回复后让访客收到邮件，用心良苦。\n\n于是我也在新增留言和文章评论的接口里，新增了给自己发送邮件提醒的功能。\n\n我用的QQ邮箱，具体如下\n\n## 一：配置邮箱\n设置中开启IMAP服务，获取授权码\n\n## 二：使用组件发送邮件\n安装nodemailer组件，填写相关字段完成发送\n```\nlet transporter = nodemailer.createTransport({\n     'host': 'smtp.qq.com',    // 主机\n     'secureConnection': true,    // 使用 SSL\n     'service': 'qq',\n     'port': 465,    // SMTP 端口\n     'auth': {\n         'user': '1585437938@qq.com',    // 账号\n         'pass': '上图获取的授权码' // 授权码\n      }\n});\nlet mailContent = {\n     from: '1585437938@qq.com', // 发件人地址 灵活填写，我是自己发给自己\n     to: '1585437938@qq.com', // 收件人地址\n     subject: '主题内容', // 主题\n     html: `这里自己拼接，可以是html模式的文本` // html body\n};\n                  \n// 发送邮件\ntransporter.sendMail(mailContent, (err, info) => {\n    if (err) {\n         console.log('发邮件出错了', err);\n    } else {\n         console.log('邮件发送成功');\n    }\n});\n```\n## 三：实例\n我的博客为了不让用户感觉繁琐，不强制访客留下邮箱等个人信息。\n\n访客留言或者评论文章后，我会自己给自己发一封邮件，来实现消息提醒。\n\n实例演示地址：见留言页面\n\n实例源码：[留言板页面代码](https://github.com/SunQQQ/SunQBlog-UserSide/blob/master/src/components/MainPage/MessageBoard.vue)\n\n## 四：修改授权码\n当时代码写完上传github了，想着我这小网站也没人关注于是带着授权码一块上传了。\n\n然后半个月后噩梦开始了，真有贱人闲的蛋疼拿着我的邮箱批量往外发垃圾邮件。\n\n于是我从新生成授权码，心想旧的授权码该失效了。然后并没有，至少不是实时失效的。\n\n网上查到更改QQ密码，之前的授权码都会失效。尝试了这个办法，旧授权码确实当场失效。\n\n然后重新生成授权码，给接口换上。接口直接上传服务器，该改动不再上传github。\n\n​",
            "CreateDate": "2023-04-20T10:35:33.374Z",
            "ArticleTag": "后端语言",
            "ArticleCover": "http://39.104.22.73:8888/email.jpg",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTY4MTM3NzA1MiwiZXhwIjozNjAwfQ==.JcdTpjaHhu1Xp81HiAjZMOA6QU1TjDDw+uw/hVQbEc8=",
            "CommentNum": 7,
            "articleReadNum": 433
        },
        {
            "_id": "622dd057519be52053ff8d08",
            "Title": "常用的几款UI框架",
            "order": "",
            "Summary": "UI组件库比较多，分类归纳下",
            "Content": "UI框架有很多，比如微信官方为公众号开发提供的WeUI、适合后端程序员使用的Layui等。UI框架一般只是给前端狗写静态页面提供方便。\n\n这类框架一般提供css和js文件，使用时引入css和js文件，然后html页面里使用框架规定的类名，或者说html页面里复制框架的html即可渲染出完整的html页面。不用再手工去表单、列表、样式等等，而且一般UI框架的兼容性、美观度都会比我们手写好很多。\n\n初学时我还好奇过UI框架和JS框架的区别，JS框架比如JQuery/Vue/React等是不牵扯到html/css等样式问题的。他们本质是让我们不需要直接使用原生JS而是用他们封装后的库去更便利的开发JS。JQuery使我们操作DOM，使用异步请求更方便，vue等使我们可以不再关注DOM操作，将精力更多的放在数据处理、代码优化上去。\n\n# 一：WeUI\nWeUI与LayUI类似，但相比之下WeUI提供的内容少一些。WeUI只是提供css文件、js文件，你复制它的html代码即可渲染出一个纯静态的列表页出来。数据动态化这块，前端狗需要自己用ajax等请求数据，用模板引擎来修改纯静态页面并渲染列表页。\n\nWeUI是一套同微信原生视觉体验一致的基础样式库,适合开发微信小程序、企业号等应用，即在微信上使用的网页。设计风格跟微信一样简洁大方。\n\n# 二：ElementUI\n这个UI框架，专门配合VUE使用。功能强大到可怕，借助它可快速开发管理后台。特点是\n\n文档清晰，每个组件的每个点都有详细的实例。\n组件异常完善，只有你想不到，没有人家做不到的。\n组件设计简洁易用，很快上手。\n用这个UI框架，就感觉自己是个工具人，对不起自己所领的薪水，人家啥都给搞定了。我们把组件拿过来拼起来就行，是我们开发速度超快。\n\n我博客的管理端用的就是ElementUI，他帮我以极快的速度就搞定了博客的管理后台。推荐大家使用这个强大的UI框架。\n\n但是不太适合使用在移动端中，比如table、导航菜单等组件也只有在管理端才会用到。这些组件的设计方式是无法直接用在移动端页面的，移动端展示数据时需要简洁明了，不能展示过多密密麻麻的数据。\n\n# 三：AUI\naui 是一套基于原生javascript开发的移动端UI组件库，包含常用js方法、字符校验、dialog提示弹窗、数字键盘、侧滑菜单、时间选择器、多级联动、聊天UI、项目常用模板。特点是：\n\n- 标准化，产品化 \n- 更多复用，更快效率 \n- 多人协作，更加统一 \n- 维护方便 \n- 易于使用 \n- 减少UI设计时间\n- \nAUI相对于weui来说更进一步，不光提供样式，使用它的方法可以直接渲染出组件了。开发移动端应用是可以参考使用，常用组件也都基本覆盖到位了。\n\n# 四：LayUI\n1.Layui比一般UI框架更加方便，不光为我们提供好静态页面，连数据交互这块也帮前端狗写好了。下面以Layui渲染列表为例，\n\n1.html中引入特定css和js文件后，写一个列表最外层的div，如<table class=\"layui-table\" id=\"test\"></table>\n2.写js代码，按LayUI提供的语法规则，新建一个table实例对象，在实例对象中将表头信息、接口地址等信息写好，打开页面即可渲染出特定样式的列表出来\nLayUI官网还提供一些其用户基于LayUI写好的开源的完整系统，比如一个具有所有功能的管理后台，让一些没有设计师或者快速开发的公司，直接拿来修改使用。\n\n但是这个框架的开发者闲心已经不再维护升级，官网已经关闭。用闲心自己的话，他让我们去拥抱变化拥抱MVVM的开发方式。他造福了中国一大堆当时从事后端但想要快速开发的人们，layui用在了无数网站上，这里向他致敬！\n\n2. 自定义模块使用\n\nLayUI自定义模块：\n\n第一步：新建一个JS文件，命名为NewModule.js，代码如下\n```\nlayui.define('layer',function (exports) {\n   layer = layui.layer;  //调用已存在模板\n   console.log(\"\");\n   var render = {\n      index:function () {\n         console.log(\"测试调用接口\");\n         layer.msg(\"好冷\");\n      }\n   };\n\n   exports('NewModule',render);    //抛出接口,加载模块时可以调用render里面的方法\n});\n```\n使用自定义模块\n```\nlayui.config({\n\t  base: '../src/'    //自定义模块放在的位置\n\t  ,version: '1.0.0-beta5'\n  }).use('NewModule',function () {\n\t\tvar NewModule = layui.NewModule;\n\t\tNewModule.index();\n  });\n```\n3.Table绑定Toolbar\n\nhtml中：\n```\n<table id='ATable' lay-filter='ATable'></table>\n<script type='text/html' id='Tpl'>\n     <button lay-event='play'>播放</button>\n</script>\nJs中：\ntable.render({\n   elem:'#ATable',                         //此处的ATable为table的id值\n   clos:[[\n        {title:'操作',toolbar:'#Tpl'}      //此处实例化table时，绑定toolbar模板文件\n       ]]\n});\ntable.on('tool(ATable)',function(obj){     //此处的ATable为table的lay-filter值\n    if(obj.evenet === 'play'){             //此处监听toolbar的点击事件\n         ... ...\n    }\n});\n```\n4.跳过的坑\n\n1.当ajax请求时只有请求头没有响应头，且提交后会刷新页面，实在找不到原因时，可能是form表单用错了。\n\n正确的写法：\n```\n<div class=\"layui-form\" style=\"padding: 30px 0 0px 0px\"></div>\n```\n错误的写法：\n```\n<form class=\"layui-form\" style=\"padding: 30px 0 0px 0px\"></form>\n```\n\n\n\n",
            "CreateDate": "2022-03-13T10:57:57.081Z",
            "ArticleTag": "技术笔记",
            "ArticleCover": "http://39.104.22.73:8888/ui.png",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTY0NDUwODE5NSwiZXhwIjozNjAwfQ==.x4qBYi8ETz98L3Fe8EtfhUJcoo49U5avZPuR7/1G9lg=",
            "CommentNum": 17,
            "articleReadNum": 1542
        },
        {
            "_id": "61e55d0ed4734e4a15bc12c6",
            "Title": "统计网站访问量（自己开发）",
            "order": "",
            "Summary": "网站的运营者或者开发者肯定都想知道，自己网站每天的使用情况。",
            "Content": "网站的运营者或者开发者肯定都想知道，自己网站每天的使用情况。比如每天有多少访问量、用户都点击哪些功能、用户对网站上哪些功能感兴趣。知道了这些信息才能定位网站后面的开发方向，比如持续优化点击率高的模块 、裁撤用户不感兴趣的模块，打造用户喜欢，且有自己特色的应用。\n\n我在我的博客上做了尝试，现在分享给大家。演示效果请看本博客的访问统计页面\n\n# 一：功能分析\n首先准备工作是分析自己的应用有哪些功能，确定我们需要监听的具体动作。\n\n比如，我分析我的博客因为功能简单，主要监听三个模块即可。再细化到每个操作是在哪里触发的，具体就是下图了\n\n1. 各种按钮操作 （6种按钮）\n2. 列表翻页（3种列表）\n3. 菜单切换（7个菜单）\n\n![](https://pic3.zhimg.com/80/v2-540d0aa859fd6d25cdd1fdc094ba9d62_720w.jpg)\n\n# 二：前端埋点\n所谓埋点就是监听各个关键节点，在节点触发时请求接口记录用户当下的这个操作日志。比如监听我博客的‘博客源码‘按钮，在该按钮被触发时发送一个日志\n```\nreadCode:function (){\n  // 创建日志\n  this.createLog({\n    moduleType:'button',\n    operateType:'查看源码',\n    operateContent:'首页入口'\n  });\n}\n```\n细化到每个触发点后，我们可以开始埋点，上传用户的操作日志了。可以封装一个埋点方法，在每个触发节点都调用这个方法并且传入如上图一样的参数\n```\n  // 封装埋点方法\n  Vue.prototype.createLog = function (log){\n    let that = this,\n      dateString = this.getSQTime();\n\n    that.GetLocation(function (LocationCityName) {\n      that.SQFrontAjax({\n        Url: '/api/visitCreate/foreend',\n        UploadData: {\n          location:LocationCityName,\n          fromUrl:document.referrer,\n          time:dateString,\n          browser:that.getSQBrowser(),\n          moduleType:log.moduleType,\n          operateType:log.operateType,\n          operateContent:log.operateContent ? log.operateContent : ''\n        },\n        Success: function () {\n          that.setSQCookie('sunqBlog','统计访问量',12); // 12个小时内同一个浏览器算一个访问量\n        }\n      });\n    });\n  };\n\n // 在页面初始化时，调用接口，上传用户的操作日志\n export default {\n    name: \"BlogIndex\",\n    mounted: function () {\n      // 创建日志\n      that.createLog({\n        moduleType:'menu',\n        operateType:'选择菜单',\n        operateContent:'博文'\n      });\n    },\n  }\n```\n# 三：数据分析\n收集到的操作日志数据长这样，一条条的很碎，看起来非常累人。\n![](https://pic4.zhimg.com/80/v2-514730141aef17930a6ef0a2d32bdb6f_720w.jpg)\n\n需要我们整理一下。比如每个ip它一天有哪些操作，把这些操作形成一个集合。\n\n比如一天中有几个ip访问，这些ip分别是什么。\n\n比如一天有多少浏览量，昨天有多少浏览量，最近一周浏览量是怎样个趋势等等\n\n这时需要我们的后端语言去开发出一个个的接口\n\n我是用的Node.js，由于我对MongoDB的操作不熟悉，就查出所有记录然后用nodejs去处理数据了。下面是用户行为接口的实现例子\n```\n// 汇总每个ip的操作行为\nApp.post('/getUserAction/:accesstype',function (Request, Response){\n    DealPara(Request, Response, function (para) {\n        let endTime = para.endTime, // 2021/12/11 从前端获取\n            dayNum = para.dayNum,//7 从前端获取\n            dayArray = util.getDateArray(endTime,dayNum), // 前推指定天数，类似[‘2021/12/09’,‘2021/12/10’,‘2021/12/11’]\n            nextDay = util.getOneDate(endTime,1),  // 输出 2021/12/12\n            nodePara = {'time':{$gt:dayArray[0],$lt:nextDay}},\n\n            ipArray = [], // ip数组 [ip1,ip2,ip3]\n            userAction = {}; // { ip1:{action:[]}, ip2:{action:[]}}\n        // 查出上面时间数组范围内所有的记录，然后遍历时间数组的每一天，跟记录对比，得出每一天的访问量\n        Monge.Mongo('VisitList', 'Read', nodePara, function (Result) {\n            Result.forEach(function (item){\n                let currentIp = item.clientIp;\n                if(item.clientIp && ipArray.indexOf(currentIp)==-1){\n                    ipArray.push(currentIp);\n                }\n            });\n\n            // 生成userAction     { ip1:{action:[]}, ip2:{action:[]}}\n            ipArray.forEach(function (item){\n                userAction[item] = {action:[]};\n            });\n\n            Result.forEach(function (item,i){\n               let currentIp = item.clientIp, // 当前数据可能没有ip字段\n                   actionarray = currentIp ? userAction[currentIp].action : '', // 当前ip下的行为数组\n                   actionText = item.operateType ? item.operateType + ':' + item.operateContent : ''; // 当条日志下的操作字段\n\n               if(actionarray && actionText && actionarray.indexOf(actionText)==-1){\n                    actionarray.push(actionText);\n               }\n\n               if(currentIp){\n                   userAction[currentIp].location = item.location ? item.location : '';\n                   userAction[currentIp].browser = item.browser ? item.browser : '';\n                   userAction[currentIp].time = item.time ? item.time : '';\n               }\n            });\n\n            var Json = {\n                status: '0',\n                data: {\n                    userAction:userAction,\n                    dateList:Result // 数据结果为库里记录直接返回，供地图使用\n                }\n            };\n            Response.json(Json);\n        });\n    });\n});\n```\n# 四：数据展示\n前端根据后端的接口，形象话的把需求展示出来。可以用echarts的折线图、地图、饼状图，列表等各种组件使接口数据可视化，下面是目前我博客分析出来的数据，还有很多信息我还没来及分析。比如各种操作的占比，我会在节假日更新\n\n![](https://pic1.zhimg.com/80/v2-b6633e14f8319adb7092932b7c1cd6ec_720w.jpg)\n\n# 五：反哺网站\n根据分析出来的数据，可以发现用户的访问习惯，了解网站各项指标，对网站进行针对性的优化\n\n#### 1、菜单名称优化\n![](https://pic4.zhimg.com/80/v2-f5c99cfd3002aac66cabb879ea2d4c0f_1440w.jpg)\n\n通过第三个饼图，可以看出用户几乎不点击管理后台这个菜单。估计是大家以为这个后台是作者自己使用的，但其实我是对外开放的，希望能跟大家分享。\n\n所以我做了如下优化，调整菜单名称：管理后台->开放式后台。估计会增加这块的访问量，后面再看看数据有没有效果\n\n![](https://pic2.zhimg.com/80/v2-f73ab2d8a45dd3e29f0c9b977631af3d_1440w.png)\n#### 2：兼顾移动设备\n![](https://pic3.zhimg.com/80/v2-830e33a70581beb3a01c2be37904d416_1440w.jpg)\n\n经过对访问用户设备占比的分析，结果如上图右上角饼图，发现有近四分之一的用户使用移动设备访问网站。\n\n比我预估的占比多，于是我把管理后台的页面添加了对移动设备的适配。兼顾到这部分用户的访问体验\n\n#### 3、提升用户粘性\n通过对老用户占比数据的分析，分析结果如上图左一。发现老用户占比不及10%，且这10%中我自己的访问量占大头。说明我的博客用户粘性很差，后面准备从博文质量、博客优化入手，提升访客的回头率。\n\n#### 4、用户行为分析\n通过对用户行为的归纳，如上图右下角。发现用户在本网站操作最多的还是浏览文章和浏览留言，其余访问统计、时间轴、管理后台等我之前以为吸引人的功能模块终究还是甜点零食，最高访问量还是博文和留言。\n\n我觉得我得珍惜这些流量，提升博文质量，审核留言。顺应用户的真实关切\n\n#### 5、流量来源\n![](https://pic2.zhimg.com/80/v2-68cc87860321f20b1f87bc16b69f26a5_1440w.jpg)\n![](https://pic1.zhimg.com/80/v2-6400e77584786c69ca914ec1f3af5c44_1440w.jpg)\n\n如上图一为我博客流量趋势，图二为我知乎账号的流量趋势。博客的流量跟知乎的流量正相关，0911是中秋节假期的第二天，知乎访问量稀碎，我的博客访问量也稀碎。\n\n说明我博客都是从知乎引流过来的，想推广我的博客还是要背靠知乎大平台，做好知乎账号才能有更多的博客访问量。\n\n\n\n\n\n\n前端详细代码：[Github地址](https://github.com/SunQQQ/SunQBlog-UserSide)\n\n后端详细代码：[Github地址](https://github.com/SunQQQ/SunQB)",
            "CreateDate": "2022-01-17T12:02:12.611Z",
            "ArticleTag": "前端开发",
            "ArticleCover": "http://39.104.22.73:8888/maiDian.jpg",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTY0MDg0NDI3MCwiZXhwIjozNjAwfQ==.9yQhW80qiKuReBGyf4gTf07tC+L/QZyjLMqh8pS6MgY=",
            "CommentNum": 13,
            "articleReadNum": 1486
        },
        {
            "_id": "61c020f77c8c8f5a224e7024",
            "Title": "前端AES加密",
            "order": "",
            "Summary": "前端请求时，当牵扯到用户姓名、电话等敏感信息的参数最好还是加密保护一下。",
            "Content": "前端请求时，当牵扯到用户姓名、电话等敏感信息的参数最好还是加密保护一下。关于加密的技术有多种，每种的使用场景不同；\n\n- MD5是单向加密，无法解密，主要用于校验。比如前端获取用户输入的密码后MD5加密，传入后端；数据库里也存的MD5字符串，后端无需解密，直接拿着这个串跟库里数据对比即可。具体使用如下：懵懂老头：前端MD5 加密\n- AES是双向加密，获取密钥后可以解密。比如前端传递加密后的用户名和电话号码给后端，后端解密后向这个电话号码发送短信。下图是AES加密使用原理\n\nAES加密使用原理\n![](https://pic4.zhimg.com/80/v2-0b1264f8cc1994cf8e1eb0c305e4bc23_720w.jpg)\n\n## 一：关于配置\n注意AES在使用时有7个配置项，前后端加解密记着统一参数，测试时注意配置项的选择是否一致\n\n\n配置项如图头部所示\n![](https://pic1.zhimg.com/80/v2-b956334dfaff56c960381db2bf617974_720w.jpg)\n## 二：安装组件\n```\n// 命令行\nnpm i crypto-js --save\n```\n## 三：具体使用\n```\nlet CryptoJS = require('crypto-js');\n\n// 加密\nfunction Encrypt(str) {\n  let key = CryptoJS.enc.Utf8.parse('1234567890ABCDEF1234567890ABCDEF'); // 密钥：一个常量，前后端协定后一个字符串即可\n  let iv = CryptoJS.enc.Utf8.parse('0123456789ABCDEF'); // 偏移量：一个常量，前后端协定后一个字符串，前后端一致即可\n\n  let srcs = CryptoJS.enc.Utf8.parse(str);\n  var encrypted = CryptoJS.AES.encrypt(srcs, key, {\n    iv: iv,\n    mode: CryptoJS.mode.CBC,  // mode 与后台一致。有多个模式可选\n    padding: CryptoJS.pad.Pkcs7, //\n  });\n\n  // 需要返回base64格式的加密结果，使用此句\n  return CryptoJS.enc.Base64.stringify(encrypted.ciphertext);\n\n  // 需要返回hex格式的加密结果，使用此句\n  // return encrypted.ciphertext.toString().toUpperCase();\n}\n\n// 解密\nfunction Decrypt(str) {\n  let key = CryptoJS.enc.Utf8.parse('1234567890ABCDEF1234567890ABCDEF'); // 密钥：一个常量，前后端协定后一个字符串即可\n  let iv = CryptoJS.enc.Utf8.parse('0123456789ABCDEF'); // 偏移量：一个常量，前后端协定后一个字符串，前后端一致即可\n\n  let base64 = CryptoJS.enc.Base64.parse(str);\n  let src = CryptoJS.enc.Base64.stringify(base64);\n\n  var decrypt = CryptoJS.AES.decrypt(src, key, {\n    iv: iv,\n    // mode: CryptoJS.mode.ECB,\n    mode: CryptoJS.mode.CBC, // mode 与后台一致。有多个模式可选\n    padding: CryptoJS.pad.Pkcs7\n  });\n\n  var decryptedStr = decrypt.toString(CryptoJS.enc.Utf8);\n  return decryptedStr.toString();\n}\n\nlet jiaMi = Encrypt('孙权');\nconsole.log('加密',jiaMi);\nconsole.log('解密',Decrypt(jiaMi));    \n```\n## 四：第三方测试工具\n在线测试工具：[测试](http://tool.chacuo.net/cryptaes)\n\n",
            "CreateDate": "2021-12-20T06:17:55.572Z",
            "ArticleTag": "前端开发",
            "ArticleCover": "http://39.104.22.73:8888/aes.jpg",
            "Token": "eyJkYXRhIjoiNWJhYjQ0ZmRjZjgxMmEyM2E0Y2ZlZjJhIiwiY3JlYXRlZCI6MTYzOTk4MTA4OCwiZXhwIjozNjAwfQ==.TN752HYlcfHWKUQuPNQHmhRYnWq5uXpj2lLFScGS7lw=",
            "CommentNum": 5,
            "articleReadNum": 433
        },
        {
            "_id": "61b9b2a3939e8b5e311f8286",
            "Title": "前端MD5 加密",
            "Summary": "MD5加密是单向加密，可以保存用户信息等",
            "Content": "关于前端加密的技术有多种，每种的使用场景不同，比如：\n- MD5是单向加密，无法解密，主要用于校验。比如前端获取用户输入的密码后MD5加密，传入后端；数据库里也存的MD5字符串，后端无需解密，直接拿着这个串跟库里数据对比即可。\n- AES是双向加密，获取密钥后可以解密。比如前端传递加密后的用户名和电话号码给后端，后端解密后向这个电话号码发送短信。AES具体使用请看我的下一篇：[前端AES 加密](https://zhuanlan.zhihu.com/p/444797115)\n# 一：MD5.js \n在网上找了好几个MD5.js，加密出来的字符串是错误的。最后找到一个好用的分享给大家，创建一个md5.js文件，把下面代码拷进去\n\n```\nvar rotateLeft = function(lValue, iShiftBits) {\n    return(lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));\n}\n\nvar addUnsigned = function(lX, lY) {\n    var lX4, lY4, lX8, lY8, lResult;\n    lX8 = (lX & 0x80000000);\n    lY8 = (lY & 0x80000000);\n    lX4 = (lX & 0x40000000);\n    lY4 = (lY & 0x40000000);\n    lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);\n    if(lX4 & lY4) return(lResult ^ 0x80000000 ^ lX8 ^ lY8);\n    if(lX4 | lY4) {\n        if(lResult & 0x40000000) return(lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n        else return(lResult ^ 0x40000000 ^ lX8 ^ lY8);\n    } else {\n        return(lResult ^ lX8 ^ lY8);\n    }\n}\n\nvar F = function(x, y, z) {\n    return(x & y) | ((~x) & z);\n}\n\nvar G = function(x, y, z) {\n    return(x & z) | (y & (~z));\n}\n\nvar H = function(x, y, z) {\n    return(x ^ y ^ z);\n}\n\nvar I = function(x, y, z) {\n    return(y ^ (x | (~z)));\n}\n\nvar FF = function(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(F(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n};\n\nvar GG = function(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(G(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n};\n\nvar HH = function(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(H(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n};\n\nvar II = function(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(I(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n};\n\nvar convertToWordArray = function(string) {\n    var lWordCount;\n    var lMessageLength = string.length;\n    var lNumberOfWordsTempOne = lMessageLength + 8;\n    var lNumberOfWordsTempTwo = (lNumberOfWordsTempOne - (lNumberOfWordsTempOne % 64)) / 64;\n    var lNumberOfWords = (lNumberOfWordsTempTwo + 1) * 16;\n    var lWordArray = Array(lNumberOfWords - 1);\n    var lBytePosition = 0;\n    var lByteCount = 0;\n    while(lByteCount < lMessageLength) {\n        lWordCount = (lByteCount - (lByteCount % 4)) / 4;\n        lBytePosition = (lByteCount % 4) * 8;\n        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));\n        lByteCount++;\n    }\n    lWordCount = (lByteCount - (lByteCount % 4)) / 4;\n    lBytePosition = (lByteCount % 4) * 8;\n    lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);\n    lWordArray[lNumberOfWords - 2] = lMessageLength << 3;\n    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;\n    return lWordArray;\n};\n\nvar wordToHex = function(lValue) {\n    var WordToHexValue = \"\",\n        WordToHexValueTemp = \"\",\n        lByte, lCount;\n    for(lCount = 0; lCount <= 3; lCount++) {\n        lByte = (lValue >>> (lCount * 8)) & 255;\n        WordToHexValueTemp = \"0\" + lByte.toString(16);\n        WordToHexValue = WordToHexValue + WordToHexValueTemp.substr(WordToHexValueTemp.length - 2, 2);\n    }\n    return WordToHexValue;\n};\n\nvar uTF8Encode = function(string) {\n    string = string.replace(/\\x0d\\x0a/g, \"\\x0a\");\n    var output = \"\";\n    for(var n = 0; n < string.length; n++) {\n        var c = string.charCodeAt(n);\n        if(c < 128) {\n            output += String.fromCharCode(c);\n        } else if((c > 127) && (c < 2048)) {\n            output += String.fromCharCode((c >> 6) | 192);\n            output += String.fromCharCode((c & 63) | 128);\n        } else {\n            output += String.fromCharCode((c >> 12) | 224);\n            output += String.fromCharCode(((c >> 6) & 63) | 128);\n            output += String.fromCharCode((c & 63) | 128);\n        }\n    }\n    return output;\n};\n\nfunction md5(string) {\n    var x = Array();\n    var k, AA, BB, CC, DD, a, b, c, d;\n    var S11 = 7,\n        S12 = 12,\n        S13 = 17,\n        S14 = 22;\n    var S21 = 5,\n        S22 = 9,\n        S23 = 14,\n        S24 = 20;\n    var S31 = 4,\n        S32 = 11,\n        S33 = 16,\n        S34 = 23;\n    var S41 = 6,\n        S42 = 10,\n        S43 = 15,\n        S44 = 21;\n    string = uTF8Encode(string);\n    x = convertToWordArray(string);\n    a = 0x67452301;\n    b = 0xEFCDAB89;\n    c = 0x98BADCFE;\n    d = 0x10325476;\n    for(k = 0; k < x.length; k += 16) {\n        AA = a;\n        BB = b;\n        CC = c;\n        DD = d;\n        a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);\n        d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);\n        c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);\n        b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);\n        a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);\n        d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);\n        c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);\n        b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);\n        a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);\n        d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);\n        c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);\n        b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);\n        a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);\n        d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);\n        c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);\n        b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);\n        a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);\n        d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);\n        c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);\n        b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);\n        a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);\n        d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);\n        c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);\n        b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);\n        a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);\n        d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);\n        c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);\n        b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);\n        a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);\n        d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);\n        c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);\n        b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);\n        a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);\n        d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);\n        c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);\n        b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);\n        a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);\n        d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);\n        c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);\n        b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);\n        a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);\n        d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);\n        c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);\n        b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);\n        a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);\n        d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);\n        c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);\n        b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);\n        a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);\n        d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);\n        c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);\n        b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);\n        a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);\n        d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);\n        c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);\n        b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);\n        a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);\n        d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);\n        c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);\n        b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);\n        a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);\n        d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);\n        c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);\n        b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);\n        a = addUnsigned(a, AA);\n        b = addUnsigned(b, BB);\n        c = addUnsigned(c, CC);\n        d = addUnsigned(d, DD);\n    }\n    var tempValue = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);\n    return tempValue.toLowerCase();\n}\n\nmodule.exports.md5 = md5\n```\n# 二：使用MD5.js\n```\nlet Md5 = require('./md5'),\n    md5 = new Md5();\nconsole.log(md5.hex_md5('123456'));\n```\n# 三：测试MD5\n可以在工具上测试自己加密后的字符串是否正确\n\n- 工具一：[加密解密测试](http://tool.sufeinet.com/Encrypt/MD5.aspx?action=Decode&md5str=%u5B59%u6743)\n- 工具二：[加密测试工具](https://md5jiami.bmcx.com/?_t=1552612737)",
            "CreateDate": "2021-12-15T09:12:23.334Z",
            "ArticleTag": "技术笔记",
            "ArticleCover": "http://39.104.22.73:8888/单向加密.jpg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTYzOTU1OTU2MSwiZXhwIjozNjAwfQ==.pkGb647Ecs/3Fz5xePrDNTVodgUfGBd2EcBH9zd3Beo=",
            "CommentNum": 2,
            "order": null,
            "articleReadNum": 287
        },
        {
            "_id": "61a9b6847cd0036dd2dafcbf",
            "Title": "Vue首屏优化",
            "Summary": "我的小博客，除了引入了echarts组件其余小组件都是自己手写的。首屏加载竟然用了6s有时甚至10s开外，看的我头皮发麻~~~",
            "Content": "我的小博客，除了引入了echarts组件其余小组件都是自己手写的。首屏加载竟然用了6s有时甚至10s开外，看的我头皮发麻，估计也劝退了很多访客。逼得我不得不优化，博客的加载效果是这样的：孙权的博客\n\n# 一：分析问题\n网上查到有一个依赖包分析工具叫webpack-bundle-anlyzer的，build后查出来我的依赖资源是如下图的。我特意在首屏加载时看了network，chunk-vendors.js在网络下载时的大小跟webpack-bundle-anlyzer分析的parsed size数据一样大都是780k，非常精确。工具使用详见下文\n\n根据工具定位到比较大的文件是chunk-vendors.js和app.js都在700kb左右，Network调试可以看到页面就是在等待这两个文件下载结束后才开始渲染，白屏的6s就是因为这2个文件下载过程导致的阻塞。\nwebpack-bundle-anlyzer的分析结果\n\n![分析结果](https://pic3.zhimg.com/80/v2-c52915c0af42582080641f9ae8510e56_720w.jpg)\n\n# 二：处理问题\n网上查了可以通过开启gzip压缩来减少超大文件的体积，我打算先压缩chunk-vendors.js等文件看看响应效果。GZip压缩倒是很��单，如下：\n### 1、安装组件\n```\nnpm install compression-webpack-plugin -S\n```\n### 2、vue.config.js配置如下\n```\nmodule.exports = {\n  configureWebpack:config=>{\n    // GZip压缩\n    const CompressionPlugin = require('compression-webpack-plugin');\n    config.plugins.push(\n      new CompressionPlugin({\n        algorithm:'gzip',\n        test:/\\.(js|css|woff|woff2|svg)$/,  // 要压缩的文件\n        threshold:10240, // 压缩超过10k的数据\n        deleteOriginalAssets:false, // 不删除压缩前的文件，如果浏览器不支持Gzip，则会加载源文件\n        minRatio:0.8 // 压缩比大于0.8的文件将不会被压缩\n      })\n    );\n  }\n};\n```\n### 3、压缩后的效果立竿见影，体积小了三分之二\n![压缩效果](https://pic2.zhimg.com/80/v2-6353440a219415cd8cbde7498ac30221_720w.jpg)\n### 4、服务器配置\n压缩好了，但是服务器还是下载.js文件，而不下载.gz文件。还是以前一样的大小，首屏加载还是那么慢。去网上查到了如下解释\n\ngz文件是在网络传输时候减小网络开销用的，在服务器配置开启gzip，请求会优先匹配同文件名的gz压缩格式返回，浏览器拿到之后会自动解压，你引用的是解压后的js或css文件\nnginx 会优先匹配你的 gzip 文件来返回，如果没有就寻找相应资源进行 gzip 压缩再返回。\n于是开始准备给服务器软件开启Gzip支持，但是我的服务是原生node��接起的，没法支持Gzip。查express/ngix/apache都支持GZip功能，于是我用express框架重写了服务，并且使用了compression组件来支持GZip功能。也很便利，大概如下：\n```\nvar express = require('express');\nvar compression = require('compression');   // 引入compresssion\n\nvar app = express();\napp.use(compression());                     // 使用compression\n\nhttp.createServer(app).listen(67);\n\napp.get('/', (req, res) => {\n  res.sendFile('index.html', {root: __dirname});\n});\n```\n### 5、使用GZip后的效果\n服务端配置GZip功能后，chunk-vendors的请求响应头显示Content-Encoding：gzip，文件下载时间163毫秒\n\n大文件从6s的下载时间变成163ms简直unbelievable！但是network显示启动器项是索引，不懂啥意思？难道服务端配置了GZip配置后还有别的提速功能？\n::: hljs-center\n\n![返回头效果](https://pic3.zhimg.com/80/v2-b7b9e26ce12dc7d140c9538db1938b6e_720w.jpg)\n\n:::\n\n![请求时间与大小](https://pic1.zhimg.com/80/v2-1de652a55ef783571fc6884c039eeb40_720w.png)\n\n### 6、结论\n目前的处理效果是首屏加载时间从6s-10s，缩减到1.4s-2s，基本满足我的需求。这个时间是我自己测的，可能也受网速等因素影响，如果亲们发现加载时间比2s多的，麻烦评论提示下。\n\n暂时先这样，等有空再优化优化。\n\n# 三：webpack-bundle-anlyzer的使用\n分析工具在vuecli3.0的使用方法很干脆，安装配置结束后打开local host:888即可看到如上页面。注意该插件会固定监听8888端口，比如npm run serve/build它都会占用8888端口，所以不能同时看编译和打包时的分析页面。安装与配置如下：\n\n```\n1、npm intall webpack-bundle-analyzer // 安装依赖\n2、在vue.config.js中配置如下\nmodule.exports = {\n  baseUrl:'./',\n  chainWebpack:config=>{\n    config\n      .plugin('webpack-bundle-analyzer')\n      .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin);\n  }\n};\n```",
            "CreateDate": "2021-12-03T06:10:04.341Z",
            "ArticleTag": "试验田",
            "ArticleCover": "http://39.104.22.73:8888/better.jpg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTYzODUxMDM4MiwiZXhwIjozNjAwfQ==.qbN0h5Rrc8azmbG5x+j9sPJ2gZb1ZTsrmAUZRhNrp/k=",
            "CommentNum": 11,
            "order": "2",
            "articleReadNum": 1288
        },
        {
            "_id": "61a48f937cd0036dd2dafbff",
            "Title": "统计网站访问量（自己开发）",
            "Summary": "想了解本博客的流量情况，但是又不想使用百度统计等，自己写了第一版欢迎拍砖~~",
            "Content": "效果展示：[流量统计页面](http://39.104.22.73:67/#/analytics)\n\n前一段想给自己的博客做一个统计访问量的功能，看看自己的网站一天有多少访客，了解下访客从哪里看到我的网站地址，以及访客都是哪个城市的。但是不想使用百度统计等工具，想自己开发这些简易的统计功能，想了很久这周终于上线了第一版。\n\n## 一：收集数据\n我的思路是在用户打开我博客的首页时，就请求我的访问统计接口。上传访问城市、上一个url、访问时间、浏览器类型等信息。为了过滤用户多次打开首页重复收集信息，我在第一次访问时就种下一个cookie，第二次访问首页时判断是否存在cookie。如果存在cookie就不再请求访问统计接口，cookie失效时间6个小时，约定6小时访问的同一个设备只记录一次。\n\n关于定位：如果没有cookie，js会请求一下我的node接口拿到访问ip，然后用该ip请求高德地图的接口，拿到访问者的城市。\n\n前端收集到访问信息后，发送给后端，node端简单的将每条数据存在mongodb。\n\n## 二：分析数据\n前端展示时会用echarts的折线图的形式绘出一周内每天的访问量，在中国地图上描出访客的城市，用列表展示每个访客的访问时间。\n\n用饼图展示各种访问占比，分析出菜单的点击比例、整体操作比例、登录后台成功的比例等等。\n\n这些数据支持由node对数据匹配分析后提供。\n\n## 三：反哺网站\n根据分析出来的数据，可以发现用户的访问习惯，了解网站各项指标，对网站进行针对性的优化\n\n#### 1、菜单名称优化\n![](https://pic4.zhimg.com/80/v2-f5c99cfd3002aac66cabb879ea2d4c0f_1440w.jpg)\n\n通过第三个饼图，可以看出用户几乎不点击管理后台这个菜单。估计是大家以为这个后台是作者自己使用的，但其实我是对外开放的，希望能跟大家分享。\n\n所以我做了如下优化，调整菜单名称：管理后台->开放式后台。估计会增加这块的访问量，后面再看看数据有没有效果\n\n![](https://pic2.zhimg.com/80/v2-f73ab2d8a45dd3e29f0c9b977631af3d_1440w.png)\n#### 2：兼顾移动设备\n![](https://pic3.zhimg.com/80/v2-830e33a70581beb3a01c2be37904d416_1440w.jpg)\n\n经过对访问用户设备占比的分析，结果如上图右上角饼图，发现有近四分之一的用户使用移动设备访问网站。\n\n比我预估的占比多，于是我把管理后台的页面添加了对移动设备的适配。兼顾到这部分用户的访问体验\n\n#### 3、提升用户粘性\n通过对老用户占比数据的分析，分析结果如上图左一。发现老用户占比不及10%，且这10%中我自己的访问量占大头。说明我的博客用户粘性很差，后面准备从博文质量、博客优化入手，提升访客的回头率。\n\n#### 4、用户行为分析\n通过对用户行为的归纳，如上图右下角。发现用户在本网站操作最多的还是浏览文章和浏览留言，其余访问统计、时间轴、管理后台等我之前以为吸引人的功能模块终究还是甜点零食，最高访问量还是博文和留言。\n\n我觉得我得珍惜这些流量，提升博文质量，审核留言。顺应用户的真实关切\n\n#### 5、流量来源\n![](https://pic2.zhimg.com/80/v2-68cc87860321f20b1f87bc16b69f26a5_1440w.jpg)\n![](https://pic1.zhimg.com/80/v2-6400e77584786c69ca914ec1f3af5c44_1440w.jpg)\n\n如上图一为我博客流量趋势，图二为我知乎账号的流量趋势。博客的流量跟知乎的流量正相关，0911是中秋节假期的第二天，知乎访问量稀碎，我的博客访问量也稀碎。\n\n说明我博客都是从知乎引流过来的，想推广我的博客还是要背靠知乎大平台，做好知乎账号才能有更多的博客访问量。\n\n\n## 四、实例源码：[GitHub地址](https://github.com/SunQQQ)",
            "CreateDate": "2021-11-29T08:22:52.597Z",
            "ArticleTag": "试验田",
            "ArticleCover": "http://39.104.22.73:8888/bigdata.jpg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTYzODE3MzI2NywiZXhwIjozNjAwfQ==.qB7N1GtImqdopWoho2uGVL8h3gsOXRv4YJ6LHXiFKak=",
            "CommentNum": 5,
            "order": "3",
            "articleReadNum": 743
        },
        {
            "_id": "61a48be67cd0036dd2dafbfe",
            "Title": "Vue使用中国地图/散点图",
            "Summary": "我用echarts展示了本博客的访问数据，让我对流量有个大致的了解~",
            "Content": "实例效果：[流量统计](http://39.104.22.73:67/#/analytics)\n\n# 全局引入\n\n1、安装echarts包\n\nnpm install echarts -S    // -S自动会修改以来表\n\n2、在main.js中引入\n\nimport echarts from 'echarts' // 如果报init找不到，修改为import * as echarts from 'echarts'\nVue.prototype.$echarts = echarts;\n\n3、在使用echarts的组件中\n```\n// 如下为折线图配置部分\nlet lineChart = this.$echarts.init(document.getElementById('lineChart'));  // lineChart为折线图要渲染的dom\nlet lineChartOption: {\n  // title: {text: '数据趋势'},\n  tooltip: {\n    trigger: 'axis'\n  },\n  legend: {\n    type: 'plain'\n  },\n  xAxis: {data: []},\n  yAxis: {},\n  series: [{\n    name: '博客访问量(人/天)', type: 'line', data: [],\n    itemStyle: {\n      normal: {\n        color:'#01aaed',\n        label: {show: true},\n        lineStyle: {color: '#01aaed'}\n      }\n    }\n  }],\n    grid: {\n    bottom: '20px' // 图表距离容器下方边距\n  }\n}\nlineChart.setOption(lineChartOption);\n\n// 如下为中国地图部分\nimport china from '../../static/map/china.json'  // 此为中国地图json数据，可从我的实例中抓取\nimport citys from '../../static/map/citys'  // ��为全国城市经纬���数据，可从我的实例中抓取\n\nlet mapOption: {\n    legend: {\n      data: ['博客访问来源']\n    },\n    tooltip: {\n      show: false\n    },\n    geo: {\n      map: \"china\",\n      roam: false,// 一定要关闭拖拽\n      zoom: 1.7,\n      center: [105, 36], // 调整地图位置\n      showLegendSymbol: false, // 存在legend时显示\n      label: {\n       normal: {\n          show: false\n        },\n        emphasis: {\n          show: true,\n          textStyle: {\n            color: \"#000000\"\n          }\n        }\n      },\n      itemStyle: {\n        normal: {\n          areaColor: \"white\",\n          borderColor: \"#aeaeae\",\n          borderWidth: 0.5\n        },\n        emphasis: {\n          areaColor: \"#f6f6f6\",\n          shadowOffsetX: 0,\n          shadowOffsetY: 0,\n          shadowBlur: 5,\n          borderWidth: 0\n        }\n      }\n    },\n    series: [{\n      name: '博客访问来源', type: 'scatter', \n      data: [], // 数据请按照实例返回的格式制造\n      itemStyle: {\n        shadowBlur: 0,\n        shadowColor: '#333',\n        normal: {\n          color:'#01aaed',\n          lineStyle: {color: '#01aaed'}\n        }\n      },\n      coordinateSystem: 'geo',\n      symbolSize: 5,\n      label: {\n        formatter: '{b}',\n        position: 'right',\n        show: true\n      },\n    }]\n}\n\nlet map = that.$echarts.init(document.getElementById('map'));\nthat.$echarts.registerMap('china', china);\nmap.setOption(mapOption);\n```\n# 二：按需引入\n\n全局引入echarts时首屏加载非常慢，我看了network。下载chunk-vendors.js文件用了6秒多，看着的我头皮发麻，改为按需引入后下载该文件用4秒左右，稍微好点\n\n1、首先不再全局引入，引入一些组件\n\n只在使用echarts的组件中引入用到的表格类型即可，如下\n```\nlet echarts = require('echarts/lib/echarts');\nrequire('echarts/lib/chart/line');\nrequire('echarts/lib/chart/map');\nrequire('echarts/lib/chart/scatter');\n\nrequire('echarts/lib/component/tooltip');\nrequire('echarts/lib/component/title');\nrequire('echarts/lib/component/legend');\n```\n2、余下的操作就跟全局引入一样了，例如：\n```\nimport Vue from 'vue';\nVue.prototype.$echarts = echarts;\nlet lineChart = this.$echarts.init(document.getElementById('lineChart'));\nlineChart.setOption(lineChartOption);\n```\n# 三、实例源码：[GitHub地址](https://github.com/SunQQQ/SunQBlog-UserSide/blob/master/src/components/MainPage/analytics.vue)\n\n\n\n",
            "CreateDate": "2021-11-29T08:07:38.839Z",
            "ArticleTag": "试验田",
            "ArticleCover": "http://39.104.22.73:8888/echarts.jpg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTYzODE3MzI2NywiZXhwIjozNjAwfQ==.qB7N1GtImqdopWoho2uGVL8h3gsOXRv4YJ6LHXiFKak=",
            "CommentNum": 0,
            "order": null,
            "articleReadNum": 664
        },
        {
            "_id": "6194a5f13ee05423fb031bd7",
            "Title": "Linux服务器基操",
            "Summary": "日常维护博客用的基础Linux操作",
            "Content": "# 一：ssh连接linux\n连接命令是用户名@ip，\n\n1：注意第一次登陆提示时需要输入yes，直接按enter会退出；\n\n2：注意输入密码时光标没有反应，这个是正常的。安全起见这个输入是不显示输入内容的，只管输入就行。\n\n```\n比如：ssh root@39.104.22.73\n```\n\n# 二：linux命令\n```\n1.操作文件：\n\npwd 打印当前位置\ncd .. 上一层\nls 列出文件夹里所有文件\nmkdir 文件名   新建文件夹\n\nrmdir 文件名   删除空文件夹\nrm -r 文件名   删除文件夹（文件夹里面还有文件夹）\nrm -rf SunQBlog-UserSide r就是向下递归不管有多少级目录删除 f就是直接强行删除，不作任何提示\ncd /文件       直接从任何位置，进入指定目录\ncd 文件        这种必须先回退到顶层，再进入指定文件\ncat -n 文件名  将文件内容显示在屏幕上\n2.查看进程：\n\n查看node进程：\nps aux | grep node 使用权限：所有使用者\n\n删除进程\nkill 进程id（进程行第一串数字）\n3.node语句一直执行\n\n使用插件后\nforever start test.js 来启动\nforever stop test.js 来停止\n4.清除终端命令记录\n\nctrl L\n5.查找文件的存放目录\n\n find -name mongodb-linux-\n6.在指定目录下载文件\n\n wget -P /etc/software  http://dev.mysql.com.mongodb.tgz\n7.解压文件\n\ntar -zxvf mongodb-linux-x86_64-ubuntu1604-4.2.8.tgz   \n8. 将文件转移到指定目录\n\nmv mongodb-src-r4.2.8  /usr/local/mongodb4                         \n9.将目录A重命名为B\n\nmv A B\n```\n# 三：进程管理\n可以使用pm2、forever等组件\n```\n如下是forever组件的用法\nforever start test.js 来启动\nforever stop test.js 来停止\n```\n# 四：关于端口\n```\n3000：用node在3000端口下起了一个静态资源服务器，死活访问不了。\n\n67、8080端口下都可以访问，不知道为啥\n```\n",
            "CreateDate": "2021-11-17T06:42:28.999Z",
            "ArticleTag": "服务器部署",
            "ArticleCover": "http://39.104.22.73:8888/linux.jpg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTYzNzEzMTM0NiwiZXhwIjozNjAwfQ==.lL4J6WtzXkSaJ4wb80IXRMlx3L/fDwqVcvUnR14H6us=",
            "CommentNum": 5,
            "articleReadNum": 196
        },
        {
            "_id": "615aff3fb82b9a529f30427b",
            "Title": "如何自学前端开发",
            "Summary": "分享下我的成长历程，欢迎大家拍砖吖～",
            "Content": "作为一个做前端开发的程序员，想跟初学者分享下自己的经验。\n\n关于学习方法，先说下我的建议吧\n\n1.入门时可以先通过W3School，大概了解HTML+CSS语法；\n\n2.从模仿某个网站的静态页面开始，然后边实践边学习。避免一直看理论知识的枯燥，并且网页的源码F12就可以直接看，方便自学；\n\n3.然后W3SChool大概学习JS，再找些弹框了等简单效果优化优化前面自己写的静态页面上，之后可以Github上找原生JS的小实例练练；\n\n4.系统性的犀牛书等经典书籍，将知识体系化；有经历也可以看点视频教程跟着练习；\n\n5.后面就可以把HTML、css、js串起来写个博客了等小应用了，最后你自己就会好奇Vue和一些UI框架了，打开前端世界的大门。\n\n下面分享下我的学习经历，有点啰嗦，大家可以跳过。\n\n2014年我还在一个二本大学的软件学院读大二上学期。跟着班里同学参加了学校的一个校企。这个校企一边接一些小项目，一边招一些学生培养。\n\n刚进去那时候还流行PHP，当时校企的技术老大是我的学长。学长让我看看w3school上面PHP部分，然后学MySQL。发现我天资愚笨，逻辑较差，可能不太适合做后端逻辑。于是教我做前端，我很相信他。\n\n前端也是给我个W3school的网址，看两天html+css。有一天打开一个网页，让我用HTML+CSS把它写出来。当时迷迷糊糊还不知道JS是啥，就开始写静态页面，写完给他看。他告诉我那里跟人家不一样，接着改。写静态页面写了好久，我都心急学习别的了。\n\n刚好团队接了学校心理素质中心开发官网的活，学长让我负责静态页面的开发。一个就不到10个静态页面吧，至今依然记得当时多开心，感觉自己竟然可以开始干项目了。写完后给他看，又改了好几版才通过。\n\n2015年我开始自己看JS，干一些小活。比如官网给团队维护的网站加个悬浮框了，新增个弹框了啥的。当时觉得JS好难，好神奇。\n\n2016年团队接了App的活，我负责Android端的开发。Android壳子里面嵌套的网页也是我开发的，这些网页也嵌套在IOS里。那时候我还做过一个微信企业号的前端，每次给我活我都开心的飞起来。也用CMS自己开发过整个网站\n\n大部分网站还是用JQuery，前后端代码搅在一起。PHP插在html里，前后端分离的开发模式好像还很少，一个后端梭哈所有。当时好像VUE还是1.0，还没有脚手架，还只有少数人开始用MVVM的技术。我们学长是个愿意尝试新技术的人，他自己搭脚手架配环境，我们开始接触VUE。当时我出去郑州面试，还没啥公司认为前端是个单独的岗位。\n\n2017年我毕业了，离开了校企。在上海帮当时入职的公司写官网，后端管理系统等。偶尔写个落地宣传页，弄个学生测评网页啥的。用的JQuery，跟领导关系也好，放养着我。为了练习VUE2.0和ElementUI，自己又看了NodeJS和mongodb，自己写了个博客孙权的博客。为了练习原生JS，写了个贪吃蛇。\n\n2021年开始在郑州易宝软件做前端开发。目前业余时间会看看犀牛书，优化优化博客，可以帮我把知识系统性的串起来。\n\n孙权的博客和贪吃蛇大家也可以拿来练手，源码在Github地址。\n\n个人博客用的知识面非常广，但是具体到每项技术用的都不深，非常适合新手练习。提高趣味性的过程中扩宽知识面，对面试和自己的技术栈都有帮助。\n",
            "CreateDate": "2021-10-04T13:12:03.758Z",
            "ArticleTag": "成长感悟",
            "ArticleCover": "http://39.104.22.73:8888/blogStudy.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTYzMzM1MzExNiwiZXhwIjozNjAwfQ==.7FiA4NrOoOb/VgVZjh6BIaIpAPFaHdFfiSwWwcrgDNE=",
            "CommentNum": 5,
            "articleReadNum": 493
        },
        {
            "_id": "615046a3fc6e535deba3ac87",
            "Title": "解决github访问慢",
            "Summary": "代码放在github上，pull、push代码的时间都要看命。。。",
            "Content": "我的代码放在github上，pull、push代码时都要看命。运气好了刷新四五次能成功，运气不好两个小时pull/push不了代码，气的差点放弃github。\n\n今天尝试了下网上的方法，同时尝试好几篇攻略才最终搞定了，分享给大家。\n\n## 一. 修改本地hosts文件\n```\nwindows系统的hosts文件的位置如下：C:\\Windows\\System32\\drivers\\etc\\hosts\n\nmac/linux系统的hosts文件的位置如下：/etc/hosts\n```\n\nmac修改hosts方法：\n```\n1.sudo vim /etc/hosts，然后输入你电脑的密码进入host文件，\n2.按 i 键进入编辑状态，修改host。\n3.ESC退出编辑状态，最后输入    :wq    保存并退出vim即可\n```\n\n\nwindows下获取hosts修改权限\n```\n1.先进入etc文件夹下,点击文件按钮;\n2.选择以管理员身份打开PowerShell,\n3.先输入cmd进入管理员界面,再输入notepad hosts ，并回车\n4.即可正常修改.具体如下图\n```\n\n\n\n\n\n## 二. 增加http://github.global.ssl.fastly.net和http://github.com的映射\n```\n获取Github相关网站的ip\n访问https://www.ipaddress.com，拉下来，找到页面中下方的“IP Address Tools – Quick Links”\n分别输入github.global.ssl.fastly.net和github.com，查询ip地址\n下面是我的配置\n140.82.114.4\tgithub.com\n199.232.5.194\tgithub.global.ssl.fastly.net\n```\n## 三.修改完hosts文件，记着刷新DNS\nMac OS X v10.6 及以上\n```\nsudo dscacheutil -flushcache\n```\nwindow：\n```\n在cmd命令行执行 ipconfig /flushdns \n```\n## 四.绝招\n最近一直有sni阻断，host这方法慢慢也不好用了。实在不行就安装一个梯子吧\n\n推荐一个免费、多平台、干净整洁、稳定的梯子：佛跳墙\n\n之前佛跳墙在github公开了源码，且有官网。我安装好了，半年后我发现代码不再开源了，而且官网也不好找了。\n我当时没有保存安装包，需要你自己去网上找了\n\n## 五.Github上的开源代码\n分享下我千辛万苦维护的开源项目,主要就两个小应用\n\n原生JS实现小游戏：[贪吃蛇](http://39.104.22.73:70/)\n\n全栈写的个人博客：[孙权的博客](http://39.104.22.73:67/)\n\nGitHub地址:[孙权的Github](https://github.com/SunQQQ)\n",
            "CreateDate": "2021-09-26T10:03:57.526Z",
            "ArticleTag": "技术笔记",
            "ArticleCover": "http://39.104.22.73:8888/blogGithub.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTYzMjY0OTQ0NCwiZXhwIjozNjAwfQ==.p1ZJrh20XsXpyBOGxRhdL2q6Jdja6Oem3jCtZci/iQg=",
            "CommentNum": 2,
            "order": null,
            "articleReadNum": 192
        },
        {
            "_id": "611e36894aed7132d3282b96",
            "Title": "重学原生js 上篇",
            "Summary": "没有系统的的学习就开始工作了，有时间还是会好好的看看犀牛书。突然发现哦原来平时用到的是这个原理...",
            "Content": "随着前端工作深入，越来越发现原生js才是王道，各种框架各种工具都是表层的东西，入手都很快。天下语言，唯原生不攻。故决定从新系统性的再研究一遍js。如下为结合W3School中ECMAScript和教学视频学习笔记。\n\n# 一：js数据类型：\n![](https://pic4.zhimg.com/80/v2-56c71a5d8c0128b3f4d4af3bff6bb91b_1440w.png)\njs有两种数据类型，分别是：\n- 原始类型：underfine，null，string，number，boolean\n- 引用类型（类）：对象。number,string，boolean都有对应的包装类对象。\n\n\n原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n\n引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体；\n\n下面是两种类型的对比：\n\n```\nvar str1 = 'a'; ----------------------原始类型\nvar str2 = new String('a'); ------包装类型\n```\n\n但是str1原始类型也能像对象一样使用str1.length（）,因为js有一个隐藏的机制，当把一个原始类型试图做引用类型（对象）一样去操作时，会智能的将它转化为包装类型对象。但是访问完后这个临时包装类型对象会被销毁掉，接下来str1.a = 5;alert(str1.a)就会返回underfiner；\n\n下面是面试经常考到的判断类型的几种方法：typeof 和 instanceof\n\n```\ntypeof:适用于判断基本类型、方法对象等。因为它判断所有对象，都返回对象\ninstanceof:适用于判断对象（object）。因为它判断的比较详细\n\ntypeof 123;          -----------------number  js的原始类型之一\ntypeof true;         -----------------boolean js的原始类型之一\ntypeof funtion;      -----------------function  疑问**********\ntypeof(undefined);   -----------------undefined undefined是js的原始类型之一\ntypeof new object(); -----------------object object是js的引用类型\ntypeof [1,3];        -----------------object 数组是对象，对象是js引用类型\ntypeof NaN;          -----------------number NaN是一个特殊的number类型\ntype null;           -----------------object null是js原始数据类型,这是语法bug\n如上如果typeof用来判断数组，返回object不够详细\n\n对应对象详细判断，可以用instanceof,它是基于原型链的。\n这个方法期望左操作数为对象类型，如果为基本类型直接返回false。\n[1,2] instanceof Array           返回true\nnew Object() instanceof Array    返回false，空对象不是array\nnull instanceof Object           返回false null如上所说是个bug，不是object\n\n\n\n在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，\n它都返回 \"object\"。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。\ninstanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。\n与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。\n例如：var oStringObject = new String(\"hello world\");\nalert(oStringObject instanceof String);\t//输出 \"true\"\n\n```\n\n两种类型的区别：\n\n- 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；\n- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；\n# 二：表达式 和 运算符\n\n![](https://pic2.zhimg.com/v2-279cdd27044af179baee3ce49923e6f1_b.png)\n![](https://pic1.zhimg.com/v2-ca6692222d67a8fafde5030c50729190_b.png)\n\n# 三：对象\njs的对象和继承有很多种实现方式如下：\n![](https://pic4.zhimg.com/v2-0e1a35f7ccbe020b77fa2d9a88de1f97_b.png)\n\n```\nvar Book = function(id,bookname,price){\n    this.id = id;\n    this.bookname= bookname;\n    this.price = price;\n}\nBook.prototype.display = function(){\n    ...\n}\nvar book = new Book(10,'js',50)；\n\n\n这段代码中类的实现和继承关系如下图：\njs类和继承这块内容太多，刚入门同学可以放后面学习哈。\n推荐大家也看看犀牛书，这块需要下功夫慢慢学的\n\n```\n\n![](https://pic4.zhimg.com/v2-012f7d577a0a2d347a3497db7467e287_b.jpg)\n\n对象中包含一系列的属性，这些属性是无序的。每个属性都有一个字符串的key和对应的value。对象的每一个属性都有一些标签，如图右边。每一个对象都自带（预设）三个属性proto、class、extensible。如下图：\n![](https://pic2.zhimg.com/v2-7d08891073ab6998658ae4f5713014b5_b.png)\n如上图是对象的结构图。因为obj的原型foo的prototype.z=3，所以obj.z第一步回去找foo有没有z属性，如果没有就找原型foo的prototype里有没有z属性。\n创建对象的方法：\n1：定义并创建对象的实例var person=new Object(); person.name='a' \n2：literals直接创建对象实例 如  对象字面量 var a = {name:'xiaoming' , age:'24' }\n3：使用函数来定义对象，然后创建新的对象实例 如  new构造器，var obj = new Foo()如下图\n![](https://pic1.zhimg.com/v2-1060ea7ca46f5861f8696d96443478ec_b.png)\n\n用new去构造一个对象的主要特点是，这个实例的原型会指向构造函数的prototype属性\n![](https://pic2.zhimg.com/v2-79a8d295694331d3ef4544ec9b0423f5_b.png)\n![](https://pic1.zhimg.com/v2-7110640d060c295d899efd9c7f85a0dc_b.png)\n\n用构造器创建对象如上，Foo()会有一个prototype属性,obj3的原型（proto）会指向构造器Foo的prototype属性。obj3为Foo的实例。当我们用function Foo(){}这个函数声明去创建一个空函数对象时,Foo会自带constructor、prototype、__proto__属性，其中__proto__为chrome浏览器创建的，ES5没有。Foo的__proto__指向Object.prototype，而ToString()、ValueOf()都是Object的prototype上的。所以原型链就产生了，Object类是Foo的父类，obj3也能用ToString()\n获取对象的属性值：\nobj3.y   或者    obj\n\n# 四：作用域 和 闭包\n\n作用域分两种：\n- 块级作用域：两个花括号中间的任何变量，外部都是不可见的，我们称之为块级作用域\n- 函数作用域：函数中定义的任何变量，外部都是不可见的。\n## 4.1 作用域\nc语言是块级作用域：j在if的{}里面，所以外面不能访问 ;js是函数作用域：因为var i是在test方法里的，所以test能访问到\n\n```\n#include <stdio.h> \nvoid main() { \n   int i=2; \n   i--; \n   if(i) { \n       int j=3; \n   } \n   printf(\"%d/n\",j); \n}\n\nfunctin test(){ \n   for(var i=0;i<3;i++){}\n   alert(i); \n} \ntest();  弹出3\n\n```\n\n## 4.2 闭包\n闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。如下代码createComparisonFunction是一个作用域，内部匿名函数也是一个作用域。createComparionFunction只能访问自己这个外面的作用域，而不能访问内部匿名函数的作用域；内部匿名函数可以访问两个作用域，自己以及createComparisonFunction。\n```\nfunction createComparisonFunction(propertyName) {\n    return function (object1,object2) {\n        var value1 = object1[propertyName];\n        var value1 = object2[propertyName];\n\n        if(value1<value2){\n          return -1;\n        }else if(value1>value2){\n          return 1;\n        }else {\n          return 0;\n        }\n    };\n}\nvar compareNames = createComparisonFunction(\"name\");\nvar result = compareNames({name:\"Nicholas\"},{name:\"Greg\"});\n```\n## 4.3 经典面试题\n闭包是经典面试题，常以选择题、编程题的形式出现。大家请注意，尤其选择题形式频率高的离谱！\n推荐一篇文章写的挺好[](https://blog.csdn.net/u013243347/article/details/52134643)[用9种办法解决 JS 闭包经典面试题之 for 循环取 i]\n\n# 五：函数\n函数是一块js代码，被定义一次，可以多次执行、调用。js中的函数比较特殊，也是对象。所以函数也能像一般对象那样操作和传递，比如给函数创建属性a、b、c，或者调用函数对象上的一些方法。函数的返回值由代码方法体中的return决定。如果没有return语句，则默认return undefinede。函数有多种创建方法和调用方式，不同的使用方法下会有一些细微的差别。\n\n创建方式：函数声明、函数表达式、函数构造器（不常用）\n![](https://pic1.zhimg.com/v2-e7571e0069983d95f8f2549ac94b9b74_b.png)\n![](https://pic1.zhimg.com/v2-6137a2a0b705010c5522e193c9f6f218_b.png)\n\n函数申明和函数表达式的区别就是，函数申明会被前置。如上图第一个可以调用方法返回3，第二个返回undefined。因为函数声明的function add()会被提前到第一句，而函数表达式的var add会被提前到第一句。也是函数前置和变量前置的区别。函数表达式其实就是用的匿名函数赋值给变量，把函数当成值来使用的情况下，都可以使用匿名函数。不过这并不是匿名函数的唯一用途\n\n![](https://pic2.zhimg.com/v2-02acefb7b08d0b1fe9b27e9b398d519d_b.png)\n\n调用方式：\n![](https://pic1.zhimg.com/v2-7b4eca01a13f89a35e8c69e0c8eb3c74_b.png)\n\n# 六：隐式转换\njs中运算符很多，常用+ - == ===,下面总结这几个运算符的隐式转换。\n\n+：当加号运算符左右两边类型相同时，比如两个int则运行数字加法；如果一边是int，一边是string，int将隐式转换为string，进行字符串拼接；\n\n-：当减号左右两边都是int，则进行数字减法；如果一边是int，一边不是int，将尝试将不是int类型的转化为int类型，再进行数字减法。\n===：严格相等，首先判断两边的类型是否一样，如果类型都不一样直接返回false。然后再判断值是否一模一样。需要注意的是NaN===NaN返回false，因为NaN无论跟什么都不是完全相等的；如果两边是对象，[1,2]===[1,2]返回false，因为除非是同一个累new出的两个相同的对象才行。\n\n==：一般相等。这个就会有隐式转换了。如果==两边类型不一样，会尝试将两边类型转化为一样再对比值是否相同。比如true==1,会将boolean转化为0或1，再对比；123=='123'，js将尝试将string转化为int再对比;null==underdefine返回true；一边是对象，一边是基本类型，将尝试将对象转换为基本类型。这部分具体实例太多，总结在下一章了懵懂老头：重学原生js  下篇\n\n# 七：声明提升\n语法：ECMAScript 的解释程序遇到未声明过的标识符时，用该变量名创建一个全局变量，并将其初始化为指定的值。（可以不声明，这样自动变成全局变量）\n\n如果都只是声明的话，函数声明提升的优先级要比变量提升高\n\n1.javascript的变量声明和函数声明提升\n如果都只是声明的话，函数声明提升的优先级要比变量提升高：\n```\nvar a; // 无论变量声明在函数声明前面还是后面，都会被函数覆盖\nfunction a(x){}\nalert(a);   \n```\n\n输出 function a(x){}\n但如果变量有赋值的话，就像题主这样，函数是无法覆盖的：\n```\nvar a = 1; \nfunction a(x){}\nalert(a);   \n输出 1\n```\n\n\n变量提升需要注意，面试基本必考。如下\n```\nvar foo=function(x,y){\n    return x-y;\n}\nfunction foo(x,y){\n    return x+y;\n}\nvar num=foo(1,2);\n```\n上面这段代码实际上的执行顺序是\n```\nvar foo,num;\nfunction foo(x,y){\n    return x+y;\n}\nfoo = function(x,y){\n    return x-y;\n}\nnum = foo(1,2);   //-1\n```\njs的运行机制是先申明变量，即使var是在后面的代码里才写的，执行时也会提前到第一行。然后函数的执行优先级更高，变量赋值次之。\n如上代码因为foo变量被赋值两次，函数式声明优先级高先执行，变量式声明优先级低后执行。后面执行的覆盖了前面执行的。\n# 八：变量回收\n\n1.局部 JavaScript 变量\n在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。\n您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。\n只要函数运行完毕，本地变量就会被删除。\n\n2.全局 JavaScript 变量\n在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。\n\n3.JavaScript 变量的生存期\nJavaScript 变量的生命期从它们被声明的时间开始。\n局部变量会在函数运行以后被删除。\n全局变量会在页面关闭后被删除。\n\n4.向未声明的 JavaScript 变量来分配值\n如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。\n这条语句：\n```\ncarname=\"Volvo\";\n```\n将声明一个全局变量 carname，即使它在函数内执行。\n\n# 九：原始类型和引用类型\n- 原始类型（直接放在栈里）：undefined,null,boolean,number,string\n- 应用类型（放在堆里，指针放在栈里）：object,boolean,number,string \n分开放是因为栈的空间有限，放一些长度确定可以。长度不固定的比如对象，就把它的指针放在栈里，因为指针长度固定。\n# 十：特殊值\n\nNaN: 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。         \n方法 parseInt() 和 parseFloat() 在不能解析指定的字符串时，或者计算0/0时，就返回这个值。         \n提示：请使用 isNaN() 全局函数来判断一个值是否是 NaN 值。if(NaN==NaN)得到false，因为NaN代表是非数字值，这个值不一定是哪个非数字值。\n\nthis:Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。\n# 十一：return \nreturn后就跳出函数。比如函数里面有个循环，循环里面有return。直接跳出循环、跳出函数。\n# 十二：++i和i++\n++前置和后置的区别在于先自加再赋值，还是先赋值再自加。\n我的记忆方式时，遇到事情大家都先从自己考虑为出发点。\n++i就是先自加再赋值，i++就是先赋值再自加\n\n```\n function out(x){\n     var temp = 2;\n     function inside(y){\n         document.write( x + y + (temp--));\n     }\n     inside(5);\n }\n out(3);      //输出：10\n\n```",
            "CreateDate": "2021-08-19T09:51:55.967Z",
            "ArticleTag": "技术笔记",
            "ArticleCover": "http://39.104.22.73:8888/js.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTYyOTM2NjcxMywiZXhwIjozNjAwfQ==.sEzBt2kehTWOY5F1z+bdmCL9Cy9AyDhTYBfvjIJSnmE=",
            "CommentNum": 5,
            "articleReadNum": 201
        },
        {
            "_id": "6111125dfe6e0b23df0fee57",
            "Title": "js实现小游戏 贪吃蛇",
            "Summary": "我18刚毕业时写的一个小游戏，当时是用来练习JS，这里分享给初学前端的同学，用于提高学习趣味性哈",
            "Content": "90后怀旧版贪吃蛇，演示地址：[贪吃蛇](http://39.104.22.73:70/)\n\n18年我初学js时写的，html/css/js全部原生手写，没有使用任何库。当时就是为了练习所学的JS，怀念下小时候手持蓝屏游戏机的感觉。代码很基础，逻辑有点乱，只适合适合新手营的同学们用来提高学习趣味性哈，不过最近我会找时间给这个版本优化优化的。下面分享下主要逻辑\n## 一.画棋盘，并控制每一个方块\n控制每一个方块逻辑：新建一个存着所有td的二维数组：如下\n先建一个（一行tr）装有30个td的数组，再将30行全部放在一个新的数组里，这样就是二维数组了。通过行列就可以定位到该td。主要逻辑如下：\n![snakecode.png](https://pic4.zhimg.com/80/v2-ded89b8364cf27a622aeed23d9cb15d7_1440w.png)\n\n## 二：控制蛇上下左右\n用一个数组装三个td作为蛇身。通过更换蛇头那个td来使蛇身前进并控制蛇头的转弯，每走一次顺次将蛇身数组前面的值往后挪一位，挤掉蛇身数组的最后一个td。主要逻辑如下：\n![snakecode2.png](https://pic1.zhimg.com/80/v2-2eb2bdeedbe426ce3b14dd1cc56d9b00_1440w.png)\n\n具体代码可在github上查看。\ngithub地址：https://github.com/SunQQQ/snake\n",
            "CreateDate": "2021-08-09T11:30:57.268Z",
            "ArticleTag": "试验田",
            "ArticleCover": "http://39.104.22.73:8888/snake.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTYyODUwNzk1NSwiZXhwIjozNjAwfQ==./uUVFnNyzRefK5hGj0FJMt23pTV7k4iNc+Wxp1uSUks=",
            "CommentNum": 7,
            "order": null,
            "articleReadNum": 864
        },
        {
            "_id": "5c1702c623c1400eb8d42f10",
            "Title": "表情包组件(vue)",
            "Summary": "想在留言和评论时使用表情包，于是在npm找个现成的组件用。后来看看还是自己写一个好了",
            "Content": "其实很早都想在博客的留言和评论处使用表情包，奈何博客需要完善的地方太多。于是一直推到了这几天，具体实现效果在[博客](博客)上可以看到。\n\n在网上查了下，发现微信官方的表情包对外开放。具体规则想如下，于是就有了思路\n```\nvar EmotionList = ['微笑', '撇嘴', '色'];//改数组没有写完全\n<img src=\"https://res.wx.qq.com/mpres/htmledition/images/icon/emotion/0.gif\">//微笑对应的动图\n<img src=\"https://res.wx.qq.com/mpres/htmledition/images/icon/emotion/1.gif\">//撇��对应的动图\n<img src=\"https://res.wx.qq.com/mpres/htmledition/images/icon/emotion/2.gif\">//色对应的动图\n```\n\n我的思路是将表情包组件做成一个子组件，在需要使用表情包的父组件里使用。\n\n首先父组件的input周围，比如留言框后会有个表情包弹框按钮。点击该按钮会弹出表情包弹框，选择表情后弹框关闭，留言框中追加进表情文字，如[[微笑]]。在form submit时，正则匹配出textarea里的像'[[微笑]]'这些字段，替换成<img https://res.wx.qq.com/mpres/htmledition/images/icon/emotion/0.gif>，然后正常上传后端接口即可。最后前端展示留言的列表展示留言文本为html格式即可。\n\n具体子父组件间交互是这样的。当父组件点击表情弹框按钮时，父组件通过Dom直接操作子组件属性，使表情弹框弹出。选择好某个表情后，表情弹框关闭，这半步在子组件内部可直接操作，无需子父交互。选中表情关闭弹框的同时还要通知父组件（emit）将选中表情的汉字追加在输入框中。最终父组件提交输入框内容时，正则匹配替换汉字表情为gif动图标签即可。\n\n具体代码如下：\n子组件（表情包）代码如下：\n```\n<template>\n    <div class=\"EmoticonListCover\" v-if=\"Show\" @click=\"OpenEmotion(false)\">\n        <div class=\"EmoticonList\">\n            <div class=\"PicItem\" v-for=\"(item,i) in EmotionList\" @click=\"ClickEmoticon(i)\" :key=\"i\">\n                <img :src=\" 'https://res.wx.qq.com/mpres/htmledition/images/icon/emotion/' + i + '.gif'\">\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n  export default {\n    name: \"Emotion\",\n    data:function(){\n      return {\n        Show:false,\n        EmotionList:['微笑', '撇嘴', '色', '发呆', '得意', '流泪', '害羞', '闭嘴', '睡', '大哭',\n          '尴尬', '发怒', '调皮', '呲牙', '惊讶', '难过', '酷', '冷汗', '抓狂', '吐', '偷笑', '可爱',\n          '白眼', '傲慢', '饥饿', '困', '惊恐', '流汗', '憨笑', '大兵', '奋斗', '咒骂', '疑问', '嘘',\n          '晕', '折磨', '衰', '骷髅', '敲打', '再见', '擦汗', '抠鼻', '鼓掌', '糗大了', '坏笑', '左哼哼',\n          '右哼哼', '哈欠', '鄙视', '委屈', '快哭了', '阴险', '亲亲', '吓', '可怜', '菜刀', '西瓜', '啤酒',\n          '篮球', '乒乓', '咖啡', '饭', '猪头', '玫瑰', '凋谢', '示爱', '爱心', '心碎', '蛋糕', '闪电', '炸弹',\n          '刀', '足球', '瓢虫', '便便', '月亮', '太阳', '礼物', '拥抱', '强', '弱', '握手', '胜利', '抱拳', '勾引',\n          '拳头', '差劲', '爱你', 'NO', 'OK', '爱情', '飞吻', '跳跳', '发抖', '怄火', '转圈', '磕头', '回头', '跳绳', '挥手',\n          '激动', '街舞', '献吻', '左太极', '右太极'],\n      }\n    },\n    methods:{\n      //选中表情\n      ClickEmoticon:function (EmoticonNo) {\n        var That = this;\n        That.Show = false;\n        That.$emit('AppendInputValue','[[' + That.EmotionList[EmoticonNo] + ']]');\n      },\n      OpenEmotion:function (Value) {\n        this.Show = Value;\n      }\n    }\n  }\n</script>\n```\n\n父组件使用如下：\n```\n<template>\n  /*表情弹框打开按钮*/\n  <span class=\"EmotionButton\" @click=\"OpenEmotions()\">\n    <i class=\"iconfont icon-face IconfontSize\"></i>\n  </span>\n\n  <Emotion ref=\"EmotionB\" @AppendInputValue=\"AppendMessageText\"></Emotion>\n</template>\n\nexport default {\n    name: \"BlogDetail\",\n    methods:{\n       // 打开表情包弹框\n       OpenEmotions:function () {\n         this.$refs.EmotionB.OpenEmotion(true);\n       },\n       //表情选中后追加在input\n       AppendMessageText:function (EmotionChinese) {\n         this.ArticleCommentText += EmotionChinese;\n       }\n    }\n}\n```\n\n代码详见github，[博客Github](https://github.com/SunQQQ)",
            "CreateDate": "2018-12-17T01:54:25.307Z",
            "ArticleTag": "试验田",
            "ArticleCover": "http://39.104.22.73:8888/facepic.jpg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0NTAxMTE1MiwiZXhwIjozNjAwfQ==.A5082TD4uSRYmpKvopADeazoX0hEkFThkAiT3gMNJh4=",
            "CommentNum": 39,
            "order": "5",
            "articleReadNum": 803
        },
        {
            "_id": "5c16178623c1400eb8d42f0b",
            "Title": "纪录片中国通史观后感",
            "Summary": "今天中国通史快看完了，觉得看的过程中有许多感受和触动记录，总结一下共勉",
            "Content": "&emsp;&emsp;上学时总是学历史，但那时候不能静下心来理解，遂看不懂其中的含义。不知道精彩在哪，也就死记硬背应付考试了，所以长大后对历史没有什么认知。\n\n&emsp;&emsp;这人上点岁数很多认知和观念都会发生变化，兴趣爱好也是。内心中慢慢的对中国历史这块未知的领域感到挺好奇，可是还是贪玩所以也只是好奇而已。近几个月，因为在公司旁边的员工宿舍住，所以每天中午可以在宿舍吃饭，还能在宿舍午休。吃饭期间喜欢看个视频，于是在哔哩哔哩上看中国通史纪录片。\n\n刚开始觉得太远的那些历史先民们肯定愚昧无知，没啥意思。看过康熙王朝、雍正王朝这些贼精彩的影视剧，折服于这些充满智慧、贤明睿智的千古一帝，所以就怀着崇拜的心情从明清开始看。\n\n&emsp;&emsp;看到英明的君主亦或开国的英雄时不禁惊呼伟大，看到屈辱到底的宋朝不禁叹息，看到闭关锁国刚愎自用的清朝晚期不禁怒骂。唐宋元明清及近代史就是这样调动着我的情绪，带给我满足好奇时的愉悦感，炒鸡开心。可是慢慢的这些'近代史'还是在我的不舍中给看完了。\n\n&emsp;&emsp;看完‘近代史’后中午饭间百无聊赖，于是不情愿的开始看远一点的历史。先从有点好奇的战国七雄开始，倒着看春秋时期、然后商周时期。中间找到了乐趣，又开始补秦汉历史。\n\n&emsp;&emsp;怀着鄙夷的态度看战国七雄时发现，哇塞，我确实是个傻子！我们的先祖在那么远古的时期就已经充满智慧了，根本就不是我认知中的愚昧无知、尚未开化。\n\n&emsp;&emsp;春秋战国时各个诸侯国此消彼长、相互学习，求贤若渴、千金买马骨，各个厉兵秣马、改革图新，异常精彩。有能取得辉煌进步而不骄傲奢淫的诸侯国如秦国，有失去一切跌入低谷但不放弃卧薪尝胆的诸侯如越王。\n\n&emsp;&emsp;春秋初期，当时的中原一霸齐国旺极一时。但别的诸侯国默默用力，专注于自身，剖析自己改革图新，随后风水轮流装，相继又出现宋襄公、晋文公、秦穆公和楚庄王等各个霸主。这让想来不够自信的自己好像明白了一些东西，让我觉得不再害怕权威，坚信只要自己不断改进、坚持不懈，我也能做到自己当前崇拜的那些大神。我也可以把我的博客开发成日PV破千的精良博客，超过我当下崇拜的网站。我也可以经过努力去进入我向往的公司，做专业的程序员。\n\n&emsp;&emsp;看过历史上那么多时期通过改革都能获得发展，让我觉得我也应该改革也可以吸收新的思想，多做尝试。所以生活上我更换发型，选不同的穿衣风格，尝试不同的生活习惯。看过那么多不畏权贵、无薪尝胆，突破阶级的英雄，我开始相信自己也可以做自己崇拜的那些人，所以我开始勤奋学习、严格律己...\n",
            "CreateDate": "2018-12-16T09:08:51.679Z",
            "ArticleTag": "成长感悟",
            "ArticleCover": "http://39.104.22.73:8888/chinaHistory.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0NDk1MTI5MywiZXhwIjozNjAwfQ==.egX5l5NnkpKC/sQCt8tFcMAy1MAlgL5h9Tu8+qNIq7I=",
            "CommentNum": 4,
            "articleReadNum": 106
        },
        {
            "_id": "5c109a9c7ef7b70eb03b9704",
            "Title": "上拉记载更多",
            "Summary": "上拉加载更多是移动端常用组件，方便优雅，代码实现上也比传统分页器更便捷。",
            "Content": "&emsp;&emsp;本博客的开发一直遵循先解决有没有，再解决好不好的思路。所有功能、设计、页面上都以最简形式先实现，后期再迭代。刚开始写分页功能，也没多想就用了传统分页。传统分页器用了一段时间，后来内容多一些，觉得还是上拉加载比较时尚方便，于是又将分页器替换为上拉加载。\n\n&emsp;&emsp;我的效果在本博客首页就能看到，形式极简。大致思路是先写一个上拉加载子组件，需要用上拉加载的父页面再调用这个子组件。\n\n&emsp;&emsp;子组件中用onScroll监听鼠标事件，纵向滚动轴滑到底部后，子组件会调用父组件方法来请求列表接口请求对应数据。\n\n&emsp;&emsp;父组件请求接口方法中，发现数据已加载完毕，则操作子组件属性，停下子组件对滚动的监听。即可实现最简版的上拉加载更多# 一级标题。\n\n子组件所有代码如下：\n```\n<template>\n    <div></div>\n</template>\n\n<script>\n  export default {\n    name: \"Pagination\",\n    data:function () {\n      return{\n        OnScroll:true\n      }\n    },\n    methods: {\n        SetUpdate:function (Value) {\n          this.OnScroll = Value;\n        }\n    },\n    created:function(){\n      var RefreshCount = 0, That = this;\n\n      window.addEventListener('scroll',()=>{\n        var ScrollTop,ClientHeight,ScrollHeight;\n        // safari要求 document.body.scrollTop\n        ScrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        ClientHeight = document.documentElement.clientHeight;\n        ScrollHeight = document.documentElement.scrollHeight;\n\n        if(ScrollHeight - ScrollTop - ClientHeight < 130 && That.OnScroll){\n          That.OnScroll = false;\n          RefreshCount += 1;\n          That.$emit('PaginationToParent',RefreshCount);\n        }\n      })\n    },\n  }\n</script>\n\n```\n\n\n父组件调用代码如下：\n```\n<template>\n  <Pagination v-on:PaginationToParent=\"ValueByPagition\" ref=\"Pagi\"></Pagination>\n</template>\n```\n\n```\nexport default {\n    methods: {\t\n      ValueByPagition:function (SelectPage) {\n        var That = this;\n        this.SQFrontAjax({\n            Url: '/api/MessageRead/foreend',\n            UploadData: {\n              PagnationData: {\n                  Skip:SelectPage * 8,\n                  Limit:8\n                }\n            },\n            Success: function (data) {\n              data.forEach(function (Item) {\n                Item.MessageLeaveDate = That.DateFormat(Item.MessageLeaveDate);\n              });\n              That.MessageList = That.MessageList.concat(data);\n              if(data.length != 8){\n                That.AticleBottom = true;\n                // 停止分页器的滚动监听\n                That.$refs.Pagi.SetUpdate(false);\n              }else {\n                That.$refs.Pagi.SetUpdate(true);\n              }\n            }\n      });\n    }\n}\n```",
            "CreateDate": "2018-12-12T05:09:19.095Z",
            "ArticleTag": "试验田",
            "ArticleCover": "http://39.104.22.73:8888/uploading.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0NDU5MTE1OCwiZXhwIjozNjAwfQ==.2k0l/9gKvDFtDMcjNeFd9MwPFkrcqDK0Dzmo4PwCxN4=",
            "CommentNum": 8,
            "order": "7",
            "articleReadNum": 264
        },
        {
            "_id": "5c0a0a494af9be0efc34f2f8",
            "Title": "Vue组件间的数据传输与通信",
            "Summary": "组件化开发的好处不言而喻，下面归纳了Vue.js中组件的通讯",
            "Content": "## 一：兄弟组件间的数据通信\n\n组件使用过程中我们发现，Loading、Tips组件的显隐设置，Topbar组件的高亮切换等操作，不是由这些组件自己控制的，是要在同级或者说兄弟组件中控制的。\n\nLoading这些组件需要别的组件向它们传输数据，然后Loading内部根据这些数据实现功能。这样Loading等就需要全局性的暴露或者说监听一个方法，其兄弟组件就可以向该全局方法传递参数，实现通讯。\n\n\n第一步：声明一个各组件都能操作到的公共实例\n\n    在main.js中声明一个bus实例：Vue.prototype.bus = new Vue\n\n第二步：被操作组件用$on监听一个方法\n\n    data(){\n        return{\n            Loading:false\n        }\n    },\n    created(){\n        var That = this;\n        this.bus.$on('Loading',function (data) {\n            That.Loading = !!data;\n        })\n    }\n\n第三步：兄弟组件通过$emit传递数据\n\n    this.bus.$emit('Loading',true);\n\n## 二：父子组件间的数据通信\n\n#### 1.父组件向子组件传值\n\n父组件在摸板中，像使用自定义标签调用子组件时，将变量放在子组件上，这样自动就传给子组件内部了。\n\n    <Pagination v-bind:Pagination=this.Pagination\n                 v-bind:PageTotalNum=this.PageTotalNum             \n                 v-bind:PageNum=this.PageNum>\n    </Pagination>\n\n子组件内部需要声明props参数，并且这些参数就不用声明直接在模板中使用了。\n\n    export default {\n      props:['Pagination','PageTotalNum','PageNum']\n    }\n\n#### 2.子组件给父组件传值\n\n子组件发送：\n\n    That.$emit('PaginationToParent',SelectPage);\n\n父组件接收：\n\n首先摸板中调用子组件时，绑定v-on方法，与子组件发送的第一个参数一致。\n\n    <Pagination v-on:PaginationToParent=\"ValueByPagition\" ></Pagination>\n\n并且什么ValueByPagition方法，这个方法接受的参数就是子组件$emit方法中第二个参数\n\n    methods:{   \n      ValueByPagition :function(SelectPage){\n        console.log(SelectPage);//此变量就是子组件$emit方法中第二个参数\n      }\n    }\n#### 3：父组件操作子组件方法\n子组件中，定义方法：\n```\nexport default {\n    name: \"Pagination\",\n    methods: {\n      SwitchPagin:function (bool) {\n        this.Pagination = bool;\n        this.PageActive = 0;\n      }\n    }\n}\n```\n\n\n\n父组件中，直接根据ref定位，调用方法即可：\n```\n<Pagination ref=\"Pagination\"></Pagination >\n\nThat.$refs.Pagination.SwitchPagin(true);\n```",
            "CreateDate": "2018-12-07T05:49:52.779Z",
            "ArticleTag": "试验田",
            "ArticleCover": "http://39.104.22.73:8888/connect.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0NDE1OTM1NSwiZXhwIjozNjAwfQ==.C+gok2sj+fX6QI2eqrbHUClov+X/AfYwSOLal+RwB0c=",
            "CommentNum": -1,
            "order": null,
            "articleReadNum": 370
        },
        {
            "_id": "5c07c113991d3b09b8c64054",
            "Title": "HTML5+CSS3 实例",
            "Summary": "下面写几个工作中遇到和自己感兴趣的Html5+css3实例",
            "Content": "## 一：HTML5 新标签\n> 1.用Audio播放音频，并写一个控制面板\n\n![v2af0261210ae36fe5457d8d1010403ac8_hd.jpg](http://www.sunq.xyz:8888/v2-af0261210ae36fe5457d8d1010403ac8_hd.jpg)\nHtml5的Audio标签用起来特别方便，Audio的标签文档如下HTML 5 <audio> 标签，对象文档如下HTML DOM Audio 对象。Audio可以在标签中直接写一个control属性，如下\n```\n<audio src=\"/i/horse.ogg\" controls=\"controls\">\n```\n即可使用默认的控制面板，但是默认控制面板在不同浏览器样式、功能不同，为了一致性决定直接写一个控制面板。控制面板主要功能：显示总时长、当前播放时长、暂停播放、显示进度条、进度条控制音频进度，如上图。\n```\n<div>\n    //Audio标签\n    <audio id=\"Audio\">您的浏览器过于老旧，请更换浏览器尝试</audio>\n    //进度条    \n    <div id=\"ProgressBack\" style=\"width: 100%;background-color: #666;\n                                        cursor:pointer;margin-top: 20px\">\n\t <div style=\"height: 5px;background-color: red;width: 0\" id=\"Progress\">\n         </div>\n    </div>\n    //左边当前时间、暂停播放按钮、总时长\n    <div style=\"text-align: center;margin-top: 70px;\">\n\t<div style=\"display: flex;vertical-align: middle;\">\n\t     <i id=\"NowTime\" style=\"width: 45%\">00.00</i>\n\t     <i class=\"layui-icon layui-icon-play\" style=\"font-size: 3rem;cursor:pointer\" id=\"Toggle\"></i>\n\t     <i id=\"TotalTime\" style=\"flex: 45%\"></i>\n\t</div>\n    </div>\n</div>\n\n/*设置资源路径*/\n$(\"#Audio\").attr('src',\"./json/Audio/man.mp3\");\n/*填写总时长*/\n$('#Audio').on(\"loadedmetadata\",function () {\n   //alert(audio.duration)\n   $('#TotalTime').text(transTime(this.duration));\n});\n/*实时更改当前播放时间*/\n$('#Audio').get(0).addEventListener('timeupdate',updateProgress);\n\n //音频结束停止播放  \n$(\"#Audio\")[0].addEventListener('ended',function () {\n     $(\"#Audio\").get(0).pause();\n     $('#Toggle').removeClass('layui-icon-pause').addClass('layui-icon-play');\n});\n\nvar ProgressBackWidth = $(\"#ProgressBack\").width();\nvar audio = $('#Audio').get(0);\n// 监听进度条\n$('#ProgressBack').click(function (e) {\n   var rate = e.offsetX/ProgressBackWidth;\n   audio.currentTime = audio.duration * rate;\n});\n//暂停、播放按钮\n$('#Toggle').click(function () {\n   if(audio.paused){\n      $(\"#Audio\").get(0).play();\n      $('#Toggle').removeClass('layui-icon-play').addClass('layui-icon-pause');\n   }else {\n      $(\"#Audio\").get(0).pause();\n      $('#Toggle').removeClass('layui-icon-pause').addClass('layui-icon-play');\n   }\n});\n//将秒转化为时间格式\nfunction transTime(time) {\n   var duration = parseInt(time);\n   var minute = parseInt(duration / 60);\n   var sec = duration % 60 + '';\n   var isM0 = ':';\n   if (minute == 0) {\n      minute = '00';\n   } else if (minute < 10) {\n      minute = '0' + minute;\n   }\n   if (sec.length == 1) {\n      sec = '0' + sec;\n   }\n   return minute + isM0 + sec\n}\n//更新进度条\nfunction updateProgress() {\n   var value = Math.round((Math.floor(audio.currentTime) / Math.floor(audio.duration)) * 100, 0);\n   $('#Progress').css('width', value+'%');\n   $('#NowTime').html(transTime(audio.currentTime));\n}\n```\n注意事项：音频的url不能使用https://\n\n> 2. canvas画个棋盘\n1.css设置画布的长宽\n\ncanvas画布是用js绘制的，能操作到canvas的每一个像素。\ncanvas的长宽应该用js设置，或者在html写canvas标签时写\n```\n// contents of js文件:\nvar canvas = document.getElementById(\"mycanvas\");\ncanvas.width=500;\ncanvas.height=400;   //注意是canvas对象\ncontent=canvas.getContext('2d');\n// contents of html文件\n<canvas width='100px' heigh='100px'></canvas>\n```\n以上两种方法都行，但是用style样式表就会出现问题，比如\n```\n// contents of css文件\ncanvas{\n    width:450px;    \n    height:450px;\n}\n```\n就会出现问题，出现一个大小不是450px的矩形。\n\n因为画布可以理解成一个照片，需要用js或写canvas标签时渲染出来。如果不渲染的话会有一个默认值，300px乘500px。所以如果不用js渲染，直接用css去设置canvas的样式，css其实设置的是默认300*500那个默认的canvas，这样会把默认那个canvas拉伸，就像css设置一个图片一样。\n\n然后就可以用css加js去操控画布啦。\n\n2.canvas要设成块元素\n\n我设置了canvas的css： margin：0 auto；死活不行，原来canvas不是块状元素\n\ndisplay: block;\n\n3.用canvas画圆 / 同心圆环\n```\n//画实心圆\nvar canva = document.getElementById(\"mycanvas\");content = canva.getContext('2d');\ncontent.beginPath();\ncontent.arc(x*30+15,y*30+15,12,0,Math.PI*2,true);      \n\ncontent.fillStyle='#000000';\ncontent.fill();    //fill是填充，stroke只是画个线\n\n//画渐变圆（圆中套一个圆）\nvar canva = document.getElementById(\"mycanvas\");\ncontent = canva.getContext('2d');\ncontent.beginPath();\ncontent.arc(x*30+15,y*30+15,12,0,Math.PI*2,true);      \ncontent.beginPath();\ncontent.arc(x*30+15,y*30+15,15,0,Math.PI*2,true);\n\nvar grd=content.createRadialGradient(x*30+15,y*30+15,0,x*30+15,y*30+15,10);\ngrd.addColorStop(0,\"#ffffff\");//白色 结合上面那句话，同一个圆心，白色远直径是零，灰色圆直径是10，最外面大圆直径是15。白色渐变，灰色也渐变就成了现在的样子\ngrd.addColorStop(1,\"#d9d9d9\");//一种灰色\ncontent.fillStyle=grd;\ncontent.fill();    //fill是填充充满，stroke只是画个线\n```\n总结：画同心圆跟画实心圆，前面都是一样的。不过是实心圆是fillstyle直接填充了个颜色。而同心圆是填充了对象。这个对象有两个圆组成，两个圆的圆心坐标相同半径不同，就有了同心圆的效果， 圆心不同就不是同心圆了。我感觉就算里面圆的半径是0，但它还是会有颜色效果的，有渐变效果。\n\n下面是用以上知识做的五子棋效果\n![v274f452727ab2dd81b1673db27d49afb7_hd.jpg](http://www.sunq.xyz:8888/v2-74f452727ab2dd81b1673db27d49afb7_hd.jpg)\n## 二：CSS3新属性\n\n1. 获取相同属性的第n个 p:nth-of-type(1) {｝ \n```\n<div class=\"infoperson\">\n    <p>{{data.info.name}}</p>\n    <p>{{data.info.depart_name}}</p>\n</div>\n.infoperson {\n        display: flex;\n        align-items: center;\n        padding-bottom: 0.6rem;\n        p:nth-of-type(1) {\n          font-size: 1.2rem;\n          margin-right: 1rem;\n          font-weight: bold;\n          color: @font_color_titleblack;\n        }\n        p:nth-of-type(2) {\n          font-size: 0.8rem;\n          color: @font_color_titleblack;\n        }\n      }\n```\n三：比较新的认知\n\n1：rem、em、px、vh等单位\n\npx和em、rem：\n\npx就是像素值，em就是根据基准来缩放字体的大小。em是相对于父元素的属性而计算的，Rem是相对于根元素<html>\n\n如果你没有在根元素指定参照值，那浏览器默认就是 1rem 为 16px,如果你指定了值假设为 20px，那 1rem 就为 20px。\n\nvh的100%是指首屏高度，当涉及到大图时贼方便。\n\n2.媒体查询\n```\nbody{\n  max-width: 640px;\n  min-width: 320px;\n  width: 100%;\n  margin: auto;\n}\n@media only screen and (min-width: 641px) {\n    .banner{\n        height: 13rem;\n    }\n    .banner img{\n        height: 13rem;\n    }\n    .formtitle{\n        text-align: center;\n        font-size: 1.2rem;\n        padding: 1rem 2rem;\n    }\n}\n````\n3：组合属性\n```\n比如：\n1.margin:5px;\n2.background:url('img/a.png');\n```\n这些属性在浏览器调试工具中都是有三角符号，能伸开的。所以用background时可以伸开看组合属性中的内容，调节具体的某项\n## 四：浮层水平垂直居中\n![v2fd8349649e657a71f9b97369899292a5_hd.jpg](http://www.sunq.xyz:8888/v2-fd8349649e657a71f9b97369899292a5_hd.jpg)\n```\n<div class=\"Cover\"></div>\n<div class=\"FormDiv\">标题</div>\n\n.Cover{\n  background-color: rgb(0, 0, 0);\n  opacity: 0.3;\n  width: 100%;\n  height: 100%;\n  left: 0%;\n  top: 0%;\n  z-index: 100;\n  position: absolute;\n}\n.FormDiv{\n  width: 700px;\n  height: 300px;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  margin: auto;\n  border: 1px solid black;\n  background:white;\n  padding: 20px 0;\n}\n```\n## 五：transition和transform\n```\n.butt {\n    width: 200px;\n    height: 30px;\n    border: 3px solid #f00;\n    background-color: #999;\n    transition: transform 400ms;\n}\n.butt:hover {\n    transform: scale(0.8,0.8);\n}\n\n<div class=\"butt\">button</div>\n```\n运行效果如此链接首页的标签效果：sunblog\n\n可见，transform只是转换效果动作，transition用于设置该transform运行的时间等，个人觉得是过程。![index.jpg](http://www.sunq.xyz:8888/index.jpg)",
            "CreateDate": "2018-12-05T12:03:29.026Z",
            "ArticleTag": "前端开发",
            "ArticleCover": "http://39.104.22.73:8888/html5+css3.jpg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0NDAxMTM3MiwiZXhwIjozNjAwfQ==.rY0D51lXZgoj3Cy9/mmv+2XcVkaykDvAsz1I9+42Srs=",
            "CommentNum": 0,
            "articleReadNum": 267
        },
        {
            "_id": "5c063b1f991d3b09b8c6404f",
            "Title": "柔软时刻",
            "Summary": "自己收藏的文章广播，在我内心柔软的时候或者心情不好时听听。这些文章或温暖、或优美、或宁静 ...",
            "Content": "\n以下为我收藏的文章广播，在我内心柔软的时候或者心情不好时听听。这些文章或温暖、或优美、或宁静 ...\n\n> 甜蜜的爱情\n\n[这大概就是感情的最美结局](http://music.163.com/dj?id=15900135&userid=386558098)\n\n[因为喜欢，所以自卑](http://music.163.com/dj?id=906492789&userid=386558098)\n\n[我甩了把初夜给我的女孩](http://music.163.com/dj?id=905126252&userid=386558098)\n\n> 关于生命\n\n[我们都擅长相见，不擅长告别](http://music.163.com/dj?id=1366508879&userid=386558098)\n\n> 懒惰时听听\n\n[有能力爱自己，有余力爱别人](http://music.163.com/dj?id=1368270640&userid=386558098)\n\n> 可爱的文章\n\n[致男友的一封信](http://music.163.com/dj?id=910649805&userid=386558098)",
            "CreateDate": "2018-12-04T08:25:40.593Z",
            "ArticleTag": "成长感悟",
            "ArticleCover": "http://39.104.22.73:8888/relax.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MzkxMTkwMywiZXhwIjozNjAwfQ==.JPCcsm21X3AyvuW07aNjJ5IaBbZxG51LNyv69qx9uwE=",
            "CommentNum": 4,
            "articleReadNum": 48
        },
        {
            "_id": "5c04ff34991d3b09b8c64045",
            "Title": "跨域问题",
            "Summary": "前端开发中跨域问题是绕不过去的坎儿，下面讨论下跨域这个事",
            "Content": "## 一：跨越问题\n\n前端开发中跨域问题是绕不过去的坎儿。下面举个例子：\n\n我们在本地开发环境下，用ajax去访问外网提供的一个接口。ajax如下图：![跨域1.jpg](http://www.sunq.xyz:8888/跨域1.jpg)\n\n然后我们在浏览器中用localhost运行这个ajax，就会因为跨域问题无法访问接口，如下截图：![跨域2.jpg](http://www.sunq.xyz:8888/跨域2.jpg)\n## 二：解决方案\n\n#### 1.方案一:\n\njsonp比较容易理解，但是由于自身机制原因只能用get请求，且需要后端配合，局限性太大。jsonp具体是应用\n```\n<script src=\"\">\n```\n\n标签可以直接跨越这个漏洞，通过get方式来请求接口。然后跟后端协商好，如果请求成功，后端打印一个拼接好的js语句来执行某个方法。然后前端就事先在js文件下面的语句中声明好这个方法。\n\n#### 2.方案二：\n\n> 2-1 apache服务器\n\n用本地服务器反向代理，不限制请求方法，前端自己搞定无需打扰后台同事，比较实用。\n\n下面介绍如何配置反向代理，我用的wampserver2.5，apach版本为2.4.9\n\n步骤一：打开apach/conf/httpd.conf文件，删除如下语句前的注释(#)\n\n```\nLoadModule proxy_module modules/mod_proxy.so\nLoadModule proxy_connect_modulemodules/mod_proxy_connect.so\nLoadModule proxy_ftp_modulemodules/mod_proxy_ftp.so\nLoadModule proxy_html_module modules/mod_proxy_html.so\nLoadModule proxy_http_modulemodules/mod_proxy_http.so\n```\n\n\n步骤二：打开apach/conf/extra/proxy-html.conf，删除76行左右如下语句前的注释(#)\n```\nProxyRequests Off  <-- this is an important security setting\n```\n配置如下核心语句，即可实现反向代理\n```\nProxyPass 随便写  外网接口\n例如：ProxyPass /proxy/ http://115.159.217.223/\n关于ProxyPass 右边第二个配置参数写代理的url(即我们要访问的那个外网接口url)。\nProxyPass右面第一个参数可以按自己意愿写，比如我们写/proxy/\n那么访问是用http://localhost/proxy/sunq/moningNight/app/\n就相当于访问http://115.159.217.223/sunq/moningNight/app/\n```\n最终ajax外网接口可以用localhost访问，这样就不存在跨域问题了。比如下图，可以与文章最上面的ajax对比url的不同。表面上不同其实如下的url实际上访问的就是上面的那个外网url\n![跨域3.jpg](http://www.sunq.xyz:8888/跨域3.jpg)\n    \n> 2-2 node.js服务器\n```\nnpm install --save cors，然后在app.js文件中\nvar cors = require('cors');  \napp.use(cors());  \n```\n## 三：Options请求（预请求）\n\n跨域可能会发送Options请求，后端判断如果是option请求，直接返回200，但不执行参数处理。\n\n将Token放在header里来请求会引起预请求，将Token放在data里来请求应该就不会引起预请求问题了\n\n可参考跨域资源共享 CORS 详解 - 阮一峰的网络日志\n## 四：跨域请求返回码\n\n今天遇到一种情况，接口是我自己写的。跨域请求时接口状态200，也有数据返回。但是服务器报跨域警告，ajax不执行success方法。\n\n我记得以前用别人接口跨域时不返回200的，直接报错误状态码的。后来问了一圈，可能是我以前没有注意这块吧，网上大哥们都说这是正常现象。跨域本来就是返回数据，但是浏览器限制不能获取数据。",
            "CreateDate": "2018-12-03T09:49:07.421Z",
            "ArticleTag": "前端开发",
            "ArticleCover": "http://39.104.22.73:8888/jump.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MzgyOTQzOSwiZXhwIjozNjAwfQ==.lY6QLSrC7BF5SCtXFOKLwmWc6GvwS1fk7of2gSQiExo=",
            "CommentNum": 0,
            "articleReadNum": 154
        },
        {
            "_id": "5bfe007f991d3b09b8c64034",
            "Title": "正则表达式",
            "Summary": "正则表达式很常用，下面是语法及实例展示，基本上覆盖全面了",
            "Content": "Regulax Expression由普通字符(也叫原义字符例如字符a~z)以及特殊字符(称为元字符)组成的文字模式。\n## 一：元字符语法\n\n#### 1.字符类\n\n[xyz] 字符集，匹配这个集合中的任一一个字符(或元字符) ，same as x|y|z\n```\n\"a1b2c3d4\".replace(/[abc]/g,\"X\");      //X1X2X3d4\n```\n[^xyz] 不匹配这个集合中的任何一个字符 ，不是这里面的任意一个字符\n```\n\"a1b2c3d4\".replace(/[^abc]/g,\"X\");      //aXbzXcXXX\n```\n#### 2.范围类\n\n[a-z]或者[0-9]\n```\n\"a1b2c3d4\".replace(/[a-z]/g,\"Q\");    //Q1Q2Q3Q4\n\"2017-10-17\".replace(/[0-9-]/g,\"A\");      //   AAAAAAAAAA   \n```\n#### 3.预定义类\n\n. 除了回车符和换行符外所有的字符（一个字符）\n\\* 匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于{0,}\n\n\\d 匹配一个字数字符，/\\d/ = /[0-9]/ bound\n\n\\D 匹配一个非字数字符，/\\D/ = /[^0-9]/\n\n\\s 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等 space\n\n\\S 匹配一个非空白字符，等于/[^\\n\\f\\r\\t\\v]/\n\n\\w 匹配一个可以组成单词的字符 word 字母数字下划线[a-zA-Z_0-9]\n\n\\W 匹配一个不可以组成单词的字符，如[\\W]匹配\"$5.98\"中的$，等于[^a-zA-Z0-9]。\n\n[\\b] 匹配一个退格符\n\n\\cX 这儿，X是一个控制符，/\\cM/匹配Ctrl-M\n\n\\n 匹配一个换行符\n\n\\r 匹配一个回车符\n\n\\t 匹配一个制表符\n\n\\v 匹配一个重直制表符\n\n##### 3-1.边界\n\n^ 以xxx开始 在字符类中表示取反 [^0-9]\n```\n'@123@abc@'.replace(/@./g,\"X\");      //X23Xbc@\n'@123@abc@'.replace(/^@./g,\"X\");      // X23@abc@  只以@开头的任意字符才会匹配，即1\n```\n$ 以xxx结束 但是^和$放的位置不一样，^放在前面，$放在后面\n```\n'@123@abc@'.replace(/.@$/g,\"X\"); // @123@abX  只以@结尾的任意字符才会匹配，即1\n```\n\\b 匹配一个单词的边界\n```\n\"this is a girl\".replace(/is/g,\"0\");     //th0 0 a girl\n\"this is a girl\".replace(/\\bis/g,\"0\");   //this 0 a girl\n\"this is a girl\".replace(/\\Bis\\b/g,\"0\");   //th0 is a girl\n```\n\\B 匹配一个单词的非边界\n##### 3-2.断言\n```\nString str =\"中华人民共和国，简称（中国）。\";  //输入括号中的中国，不要括号\nMatcher mat = Pattern.compile(\"(?<=\\\\（)(\\\\S+)(?=\\\\）)\").matcher(str);//此处是中文输入的\n```\n\n#### 4.量词\n\n```\n？出现零次或者一次\n\n+ 出现一次或多次\n\n* 出现零次或多次(任意次)\n\n{n} 出现n次\n\n{n,m} 出现n到m次\n\n{n,} 至少出现n次\n\n```\n\n\n##### 4-1.贪婪和非贪婪模式\n\n'a12345678'.replace(/\\d{3,6}/g,\"A\"); //aA78\n\n贪婪模式：如果直接{3,6}系统会按最大的,意思会将6个数字替换成A\n\n非贪婪模式：加？\n```\n'a12345678'.replace(/\\d{3,6}?/g,\"A\"); //aAA78 加了?后将三个数字换成A，但是g所以AA\n```\n#### 5.分组 ( )\n\n想匹配字母数字三次，如果只是\"a1b2c3d4\".replace(/[a-z][0-9]{3}/g,\"A\");虽然也是字母数字匹配三次，是不行的\n```\n使用分组才行\"a1b2c3d4\".replace(/([a-z][0-9]){3}/g,\"A\"); //\"Ad4\"\n```\n##### 5-1.或 |\n\n如果只是匹配名字中的两部分：\n```\n'ByronCasper'.replace(/Byron|Casper/g,'X');      //XX\n```\n如果匹配名字中的四个单词：\n```\n'ByronsperByrCasper'.replace(/Byr(on|Ca)sper/g,'X');           //XX\n```\n###### 5-2-1.反向引用(自己理解就是把某个分组声明成变量,变量用$n来取值,n从1开始)\n\n比如：2015-12-25 => 12/25/2015\n```\n'2015-12-25'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/,'$2/$3/$1');\n```\n只有用反向引用才能达到这个效果\n\n###### 5-2-2.反向引用但忽略分组(不用某个变量，在分组内加上?:就可以)\n```\n'2015-12-25'.replace(/(?:\\d{4})-(\\d{2})-(\\d{2})/,'$1');\n```\n如果给第一个分组引用加上?:，那个$1就是第二个分组了\n\n#### 6.前瞻和后顾\n\n正则是从前往后匹配，所以字符串尾部是前，头部是后。js不支持后顾。\n```\n    正向前瞻exp(?=assert)负向前瞻exp(?!assert)\n```\nexp表示正则表达式，(?=assert)叫断言也是正则表达式。正向前瞻就是不光匹配正则还要符合断言部分，负向前瞻就是不匹配断言部分。就是说只是匹配了正则还不行，还要看看后面的字符匹配断言不。替换或者操作的只是正则部分，不会操作断言部分。\n\n比如要一个前面是单词且后面是数字，替换掉单词\n```\n'a2*3'.replace(/\\w(?=\\d)/g,\"X\");   //X2*3\n'a2*34vv'.replace(/\\w(?=\\d)/g,\"X\");   //X2*X4vv\n```\n\n比如要一个前面是单词且后面不是数字，替换掉单词\n```\n'a2*34vv'.replace(/\\w(?!\\d)/g,\"X\"); //aX*3XXX\n```\n#### 7.匹配斜杆\n```\n\"2017/20/10\".replace(/\\//g,\"-\");\n```\n## 二.例子\n\n##### 1.匹配一个“ ab+数字+任意字符 ”的字符串\n\n预定义类写法：/ab\\d./\n\n范围类写法：/ab[0-9][^\\r\\n]/\n\n##### 2.检测电话号\n```\nfunction CheckPhone(InputId) {\n   var Patter = /[0-9]/g;\n   var NumLength = $(\"#\"+InputId).val();\n   if(Patter.test(NumLength) && ((NumLength.length == 11) || (NumLength.length == 8))){\n      return true;\n   }else {\n      layer.msg(\"电话号码格式有误\");\n      return false;\n   }\n}\n```\n##### 3.替换中括号中的内容\n```\nvar MyString = '[[害羞]]我要好好过呀[[微笑]]';\nMyString = MyString.replace(/\\[\\[.*?\\]\\]/g,'a');\nconsole.log(MyString);       a我要好好过呀a\n```\n##### 4.获取中括号里的内容\n```\n//不保留中括号\nvar MyString = '[[害羞]]我要好好过呀[[微笑]]';\nMyString = MyString.match(/(?<=\\[\\[).*?(?=\\]\\])/g);\nconsole.log(MyString);\n结果 [\"害羞\", \"微笑\"]\n```\n```\n//保留中括号\nvar MyString = '[[害羞]]我要好好过呀[[微笑]]';\nMyString = MyString.match(/\\[\\[.*?\\]\\]/g);\nconsole.log(MyString);\n结果 [\"[[害羞]]\", \"[[微笑]]\"]\n```\n",
            "CreateDate": "2018-11-28T02:35:33.217Z",
            "ArticleTag": "技术笔记",
            "ArticleCover": "http://39.104.22.73:8888/reg.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MzM3MjQ3OCwiZXhwIjozNjAwfQ==.RMG7e93ihOTdp5Dl2LnK59JOONXYMujtP3M175rfNyg=",
            "CommentNum": 4,
            "articleReadNum": 118,
            "order": null
        },
        {
            "_id": "5bfcb5f7991d3b09b8c64033",
            "Title": "前端常用小功能总结",
            "Summary": "总结一些前端经常遇到的场景",
            "Content": "### 一：实时搜索\n\n项目需要一个能根据input框键入内容实时搜索的功能，JQ中有一个属性可以监听input框内任何属性有一点变化的方法，该方法下在input中拼拼音时，也会监听到字母的变化。可是我们想监听input框中键入一个汉字，或者说汉字发生变化时再触发方法。可是没有可以直接实现此需求的方法。曲线实现下，判断input中全为中文时才触发\n\n```\nhtml:\n<input id=\"SearchInput\">\n\nJs:\n//判断全是中文的方法\nfunction IsAllChina(str) {\n   var reg =  /^[\\u4E00-\\u9FA5]+$/;\n   if (!reg.test(str)) {\n      return false;\n   } else {\n      return true;\n   }\n}\n$('#SearchInput').bind('input propertychange', function() {\n      if(IsAllChina($(this).val())){\n           ... ...\n      }\n});\n```\n### 二：本地存储\n\n1：应用场景\n\n当在一个页面想去用另外一个网页的数据时，可以用到web本地存储。\n\nlocalStorage的数据存储在你的浏览器上，所以你可以跨页面使用数据，具体可以在浏览器的调试工具中看到本地存储的键值对。\n\n2：存储\n\n具体用法中需要注意的是localStorage使用键值对的方法存储的，比如以下两种皆可实现存储一个值。\n\n    localStorage.setItem(\"test\",\"bilibi\");localStorage.test = \"bilibi\";\n\n但键值对的值必须是字符串，可我们经常需要存储一个对象。如果直接将一个对象放在一个键值对的值中对象就会默认被toString处理成字符串，这时就不太好处理了。\n\n我们可以在存值时现将对象转成JSON字符串，取值时再将JSON字符串恢复成JSON对象，来实现本地保存对象。如下简单封装：\n```\nfunction SQLocalStorage(key, value) {\n   if (!key) return false;\n   return value?localStorage.setItem(key,JSON.stringify(value))\n   :JSON.parse(localStorage.getItem(key));\n};\n```\n3：删除\n\n删除某个字段：localStorage.removeItem(\"Extension\");\n\n删除全部缓存：localStorage.clear();\n\n### 三：数据滤重\n比如有如下数据，要求将id相同的数据滤重，并将它们的name拼在一起。\n```\nvar a = [\n{id:'001',name:'sq'},\n{id:'002',name:'zk'},\n{id:'003',name:'sp'},\n{id:'001',name:'papa'},\n{id:'004',name:'bilibili'}\n... ...\n]\n```\n这种情况下也只有老老实实排序，不管冒泡排序还是别的排序方法。可以在内外层遍历里，如果内层id等于外层id，统一将内层数据制空(赋值为{})，并将相加的字符串给外层。然后再处理一遍将所有空对象剔除掉(可以建一个新数组，push进新数组中)。\n### 四：二级联动\n\n固定Dom的二级联动，监听第一个Select的选中事件。如果选中就根据选中值请求数据填充第二个select的option。\n### 五：转换秒为时分秒\n以秒转 分秒 为例，利用js语法特点，/(整除)然后取整可以拿到分，%(求余)即可拿到整除余下的那些秒，然后整除(时)拼接%(秒)，可以拿到分秒；时分同理可得\n```\n/*秒转换为时分*/\nfunction FormatSeconds(value) {\n    var secondTime = parseInt(value);// 秒\n    var minuteTime = 0;// 分\n    var hourTime = 0;// 小时\n    if(secondTime > 60) {//如果秒数大于60，将秒数转换成整数\n        //获取分钟，除以60取整数，得到整数分钟\n        minuteTime = parseInt(secondTime / 60);\n        //获取秒数，秒数取佘，得到整数秒数\n        secondTime = parseInt(secondTime % 60);\n        //如果分钟大于60，将分钟转换成小时\n        if(minuteTime > 60) {\n            //获取小时，获取分钟除以60，得到整数小时\n            hourTime = parseInt(minuteTime / 60);\n            //获取小时后取佘的分，获取分钟除以60取佘的分\n            minuteTime = parseInt(minuteTime % 60);\n        }\n    }\n    var result = \"\" + parseInt(secondTime) + \"秒\";\n\n    if(minuteTime > 0) {\n        result = \"\" + parseInt(minuteTime) + \"分\" + result;\n    }\n    if(hourTime > 0) {\n        result = \"\" + parseInt(hourTime) + \"小时\" + result;\n    }\n    return result;\n}\n```\n### 六：时间戳转年月日时分秒\n\njs提供了获取年月日时分秒的每一个对应的方法\n### 七.分批上传\n\n一次http请求上传超大数据时(比如一个存两万个对象的数组)会卡死浏览器，这时需要分批上传。递归来传可破\n### 八：点击高亮\n![image.png](http://www.sunq.xyz:8888/image.png)\n1.如果操作DOM\n```\n<div id=\"ViewIndexStatisType\">\n\t<span class=\"FontColor All\" onclick=\"EditClass(0)\">第一</span>\n\t<span class=\"FontColor\" onclick=\"EditClass(1)\">第二</span>\n\t<span class=\"FontColor\" onclick=\"EditClass(2)\">第三</span>\n</div>\n<script src=\"js/jquery-3.2.1.min.js\"></script>\n<script>\nfunction EditClass(Num) {\n    for(var i=0;i<$(\"#ViewIndexStatisType span\").length;i++){\n        $(\"#ViewIndexStatisType\").find(\"span\").eq(i).removeClass(\"All\");\n    }\n    $(\"#ViewIndexStatisType\").find(\"span\").eq(Num).addClass(\"All\");\n}\n</script>\n```\njquery还有一个贼方便的方法siblings。使用在当前dom上，可以遍历该dom的兄弟元素（不包括自己），批量处理别的Dom。\n```\ndom.addClass('layui-table-click').siblings().removeClass('layui-table-click');\n```\n2.如果不操作DOM\n\n类似vue等框架是不支持操作DOM的，一切都用数据解决\n\n不操作DOM可查Vue使用笔记\n### 九：获取本周、本月\n```\n/*\n   获取本周的某一天\n   getTime(0) 本周第一天 比如：返回2018-06-25\n   getTime(-6) 本周最后一天 比如：返回2018-07-01\n**/\nfunction getCurrentWeekTime(n){\n    var now=new Date();\n    var year=now.getFullYear();\n\n    var month=now.getMonth()+1;\n    var date=now.getDate();\n    var day=now.getDay();\n\n    if(day!==0){\n        n=n+(day-1);\n    }\n    else{\n        n=n+day;\n    }\n    if(day){\n        if(month>1){\n            month=month;\n        }\n        else{\n            year=year-1;\n            month=12;\n        }\n    }\n    now.setDate(now.getDate()-n);\n    year=now.getFullYear();\n    month=now.getMonth()+1;\n    date=now.getDate();\n    s=year+\"-\"+(month<10?('0'+month):month)+\"-\"+(date<10?('0'+date):date);\n    return s;\n}\n/*\n   获取本月时间\n   第一天：GetCurrentMonth('Begin') 返回：2016-06-01\n   最后一天：GetCurrentMonth('End') 返回：2016-06-30\n   * */\nfunction GetCurrentMonth(Type){\n    var Result;\n    var Now = new Date();\n    var Year = Now.getFullYear();\n    var Month = Now.getMonth()+1<10 ? \"0\"+(Now.getMonth()+1) : Now.getMonth()+1;\n    if(Type == 'Begin'){\n        Result = Year + \"-\" + Month + \"-\" + \"01\";\n    }\n\n    if(Type == 'End'){\n        var MonthLastDay = new Date(Year,Now.getMonth()+1,0).getDate();\n        Result = Year + \"-\" + Month + \"-\" + MonthLastDay;\n    }\n    return Result;\n}\n```\n### 十：浮点数精度处理\n\n由于浮点数直接相加会出现小数点后尾数太多的问题，可以做一系列转换来解决。先乘于1000然后转成字符串，然后截取小数点后面的字符。这样来保持精度。",
            "CreateDate": "2018-11-27T03:04:59.169Z",
            "ArticleTag": "前端开发",
            "ArticleCover": "http://39.104.22.73:8888/tools.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MzI4Nzg2MiwiZXhwIjozNjAwfQ==.FTID7My5JwRXrfFHScFcVNdUMZ3Y6+uV2njunGwb1XQ=",
            "CommentNum": 2,
            "articleReadNum": 126
        },
        {
            "_id": "5bfb6300991d3b09b8c64032",
            "Title": "Mongodb简单操作",
            "Summary": "记录下本博客用到的关于Mongodb的入门级操作",
            "Content": "# 一：下表列出了 RDBMS 与 MongoDB 对应的术语：\n![图片.png](http://www.sunq.xyz:8888/图片.png)\n类似于mysql，刚开始数据库、集合都是要创建之后才有的。\n\n但是每次插入数据时都是插入一个对象，整个对象就是文档，对象的属性名就是字段。字段是不需在提前创建时声明的，每次插入文档时随意添加的。\n\n这点跟mysql还是有较大差别的，mysql在创建表格时需要指定有哪些列。插入数据时也要严格根据列名顺序填写。mongodb在创建集合时不需要声明有哪些字段，插入文档时也可以随意插入对象。\n# 二：安装及使用\n\n1.下载地址：https://www.mongodb.com/download-center#community\n\n下载.msi，点击安装即可，安装过程可能会很久，我两次都是安装一夜。如果安装太久中间打断好像也不影响安装。具体安装可看如下链接：\n\nwindows下MongoDB的安装及配置 - CSDN博客\n> \n安装总结如下：\n1.安装；\n2.然后建db文件夹里面放data文件夹，配置db这个文件地址；\n3.建log文件夹建config文件写文件内容，配置文件地址；\n4.使用mongdb（mongodb安装目录bin下双击mongo.exe）\n新版4.0的mongodb自动配置了以上内容，无需再手动配置\n\n2.常用命令 （mongo的操作命令有点像js的方法调用）\n\ndb 显示所有数据库    （假如有个库叫test）\nuse test  使用test数据库   \nshow collections 显示所有集合（表）   假如有个集合叫runoob\ndb.runoob.find().pretty();  读集合runoob里的所有文档（行）   db不是指某个具体的数据库名字，就是db\ndb.runoob.findOne('5b2cc5ee4839f91d68b4bb2f');   读取_Id 为‘xxxx’的数据\ndb.runoob.insert({name:'孙权'});\ndb.runoob.remove({'name':\"孙权\"})    根据属性删除某些文档，删除name字段是孙权的所有文档\ndb.runoob.remove({})   删除所有文档\ndb.createCollection(name,options)  创建集合，options可选参数\ndb.runoob.update({'Title':'关于本博客'},{$set:{'CommentNum':0}});  修改数据\n\n3.node操作数据库\n\n```\nvar MongoClient = require(\"mongodb\").MongoClient\n   , assert = require('assert');\nvar Url = \"mongodb://localhost:27017/\";\n\nfunction Mongo() {\n   MongoClient.connect(Url,function (err,db) {\n      assert.equal(null,err);     //\n      console.log(\"数据库已建立\");\n      var DB = db.db(\"test\");\n      var MyInfo = {name:'孙权',age:24,money:100000};\n      DB.collection(\"runoob\").insertOne(MyInfo, function(err, res) {\n         console.log(\"文档插入成功\");\n         db.close();\n      });\n   });\n}\n```\n\n# 三：导出mongodb数据库\n\n主要以下三点：\n\n1.一次只能导出一个集合，且必须选择一个集合\n\n2.集合中具体的字段可以不写\n\n3.必须在bin文件夹下，运行命令行\n\nmongoexport -d test -c runoob -o C:\\Mongodb\\runoob.json --type json\n导出比较简单，如下：\n\nmongoimport -d test -c Users --file C:\\dbs\\runoob.json",
            "CreateDate": "2018-11-25",
            "ArticleTag": "后端语言",
            "ArticleCover": "http://39.104.22.73:8888/mongo.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MzIwMDg2OSwiZXhwIjozNjAwfQ==.k8qR4AsvFztKvVWd1JrcT//gW+Y7qsgoaDGQ2rYQzkM=",
            "CommentNum": 0,
            "articleReadNum": 62
        },
        {
            "_id": "5bfb60e5991d3b09b8c64030",
            "Title": "关于options请求",
            "Summary": "上次header中传值时出现了options请求，记录一下",
            "Content": "有时我们在浏览器中发现发送的ajax请求自动请求两次，第一次是options请求，第二次才是你自己发送的get或post请求。\n\n有时我们也会发现，自己用的get或者post方法请求的，浏览器只有一个options请求。自己的get或post请求却没有。因为options请求即预请求没有通过，所以后面的get或post请求就不会建立。\n\n预请求不通过是因为你在header请求头里也传了参数，即传说中的设置了自定义的请求头。这时就需要在服务器端设置响应头：\n\n> Access-Control-Allow-Headers:字段1,字段2\n\n字段1，字段2，分别对应你header中上传的字段。当然如果只有一个就只写一个，有多个就写多个，并用逗号分隔。",
            "CreateDate": "2018-11-24",
            "ArticleTag": "前端开发",
            "ArticleCover": "http://39.104.22.73:8888/ajax.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MzIwMDg2OSwiZXhwIjozNjAwfQ==.k8qR4AsvFztKvVWd1JrcT//gW+Y7qsgoaDGQ2rYQzkM=",
            "CommentNum": 0,
            "articleReadNum": 25
        },
        {
            "_id": "5bf75d4e991d3b09b8c6402d",
            "Title": "Express使用笔记",
            "Summary": "Node.js的框架使用记录，入门级的",
            "Content": "# 一：get/post参数获取\n\n1.Get获取：\n\n```\nApp.post('/ArticleRead/:accesstype', function (req, res) {\n  console.log(req.query);\n});\n```\n\n\n2.Post获取：\n\n原生node对post参数的获取是很麻烦的，\n\n```\nreq.on('data', function (chunk) {\n body += chunk;  //一定要使用+=，如果body=chunk，因为请求favicon.ico，body会等于{}\n console.log(\"chunk:\",chunk);\n}); \n```\n\n\nExpress里，与get请求不同，post请求还必须引入中间件body-parser，才能使用req.body。req默认是没有body这个字段的，使用了中间件，才后期在req中加入了body这个字段的。\n\n```\nApp.use(BodyParse.json());\nApp.use(BodyParse.urlencoded({extended:true}));\n\nApp.post('/ArticleRead/:accesstype', function (req, res) {\n  console.log(req.body);\n});\n```\n\n二：规划路由\n\n1.举栗一\n\nUrl是这样 http://localhost:8088/TagRead/foreend\n\n```\nApp.post('/TagRead/:accesstype', function (req, res) {\n  Request.params.accesstype得到的就是'foreend'\n}\n```\n\n2.举栗二\n\n```\nvar App = express();\nApp.get('/list/:listname/:id',function(req,res,next){\n  var listname = req.params.listname;\n  var id = req.params.id;\n  res.send('This is' + listname + ':' + id);\n});\n```\n\n\n前端请求时：http://localhost:1234/list/news/123\n输出：This is news:123\n",
            "CreateDate": "2018-11-23T01:49:33.535Z",
            "ArticleTag": "后端语言",
            "ArticleCover": "http://39.104.22.73:8888/express.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MjkzNjA5MiwiZXhwIjozNjAwfQ==.5sxVzpLXZvuBFUz8iJf/drScJSNts/OCuRN6rElfLKI=",
            "CommentNum": 0,
            "articleReadNum": 81
        },
        {
            "_id": "5bf61be472e9580e506ff3e1",
            "Title": "博客服务器搭建(win server 2012)",
            "Summary": "博客服务器搭建的各个坑，比如Apache、FTP、虚拟目录等",
            "Content": "# 一：打开端口\n服务器上装了一个mongodb，监听的8888端口。服务器浏览器本地访问8888端口，可以正常访问，内网访问也可以，但是外网ip访问不了这个端口。\n\n这时需要为服务器新增这个8888端口，具体操作可参考，https://jingyan.baidu.com/article/e75057f2c463e8ebc81a8960.html\n\n# 二：Apache\n1.安装apache\n\nApache服务器的下载与安装 - zhangnana200的博客 - CSDN博客\n\n2.apache网站根目录\n\n地址：Apache24/htdocs/\n\n3.外网访问\n\n设置外网访问时记着开端口的防火墙\n\n# 三：配置FTP\n网上有很多办法，自己搜吧。踩过的坑如下两个：\n\n1.记着给服务器FTP对应的端口设置防火墙。\n\n比如我的FTP用的21端口，我开放了20和21两个端口\n\n2.用FileZilla链接，报错150 Opening BINARY mode data connection.\n\n但是用webstorm的ftp工具链接没有问题。这时改fileZilla对应站点的传输设置为主动。\n![image.png](http://www.sunq.xyz:8888/image.png)\n# 四：解除80端口占用\n开启apache时发现，启动不了，查了查说可能是80端口被占用\n\n1.查找80端口的占用者\n\nnetstat -ano\n![v26b4471b9fe2ac3a80a09309a2777035b_hd.jpg](http://www.sunq.xyz:8888/v2-6b4471b9fe2ac3a80a09309a2777035b_hd.jpg)\n再去任务管理器，查到是system占用了。看选中行前面名称。\n![v253e53528c830e2c3017769460243d0a4_hd.jpg](http://www.sunq.xyz:8888/v2-53e53528c830e2c3017769460243d0a4_hd.jpg)\nsystem占用，一般是因为sqlserver、迅雷、IIS这些默认端口用80的应用。我只用了IIS\n\n2.关闭IIS/修改IIS的端口号\n\n关闭IIS或者修改IIS的端口号，就可以解决80端口占用的问题了。关掉IIS FTP也不能用了，如果想保留FTP还是修改IIS端口号，不关闭IIS。\n\n刚关闭IIS时，任务管理器中80端口还显示是system在用。但是可能是没刷新，或者什么别的原因。反正这时候去启动apache是可以的，而且启动后再看80端口就是apache在用了。\n![v2e42c797f93c7703868ab7b456b1333f5_hd.jpg](http://www.sunq.xyz:8888/v2-e42c797f93c7703868ab7b456b1333f5_hd.jpg)\n![v2b0c2ceb400cbdf5a72b66b824e34de5a_hd.jpg](http://www.sunq.xyz:8888/v2-b0c2ceb400cbdf5a72b66b824e34de5a_hd.jpg)\n\n![v2a941a7848dfd36b733d1b1807b9ff22b_hd.jpg](http://www.sunq.xyz:8888/v2-a941a7848dfd36b733d1b1807b9ff22b_hd.jpg)\n![v24b94271214b3c55bf96231804d391985_hd.jpg](http://www.sunq.xyz:8888/v2-4b94271214b3c55bf96231804d391985_hd.jpg)\n# 五：配置虚拟目录\n虚拟目录是一个影射，由一个url映射到服务器的一个目录。\n\n比如我们需要打开一个域名时就直接打开某个静态目录文件目录。如果按照apache默认那个静态网页根目录，可能需要在url中加入文件夹名字，就暴露了服务器路径。举个例子：\n\n如果不设置虚拟目录，需要这样经过font文件夹，才能打开博客首页。因为博客的静态网页在font文件夹里面放着\n\n```\nwww.sunq.xyz/font\n```\n\n如果用了虚拟目录，这样就可以跳过文件夹目录，直接打开博客首页了。下面就可以直接打开\n\n```\nwww.sunq.xyz\n```\n\n配置代码如下：当然首先要在httpd.conf中引入httpd-vhosts.conf文件\n\nhttpd-vhosts.conf下\n\n```\n<VirtualHost *:80>\n\tDocumentRoot \"C:/Program Files/Apache24/htdocs/font\"\n\tServerName www.sunq.xyz\n\tErrorLog \"logs/dummy-host2.example.com-error.log\"\n    CustomLog \"logs/dummy-host2.example.com-access.log\" common\n</VirtualHost>\n```\n\n# 六：设置二级域名\n\nhttpd-vhosts.conf下\n\n```\n<VirtualHost *:80>\n\tDocumentRoot \"C:/Program Files/Apache24/htdocs/back\"\n\tServerName admin.sunq.xyz\n\tErrorLog \"logs/dummy-host2.example.com-error.log\"\n    CustomLog \"logs/dummy-host2.example.com-access.log\" common\n</VirtualHost>\n```\n\n然后记得CDN域名解析，我的域名在腾讯云买的，就在腾讯云上设置即可。",
            "CreateDate": "2018-11-22T02:51:31.423Z",
            "ArticleTag": "服务器部署",
            "ArticleCover": "http://39.104.22.73:8888/u=1027801245,1570110167&fm=26&gp=0.jpg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0Mjg1NDA4NiwiZXhwIjozNjAwfQ==.x497sYAcBy/bA50rR17peOQuYyn+3wPs5jRBeJD+Uo4=",
            "CommentNum": 0,
            "articleReadNum": 89
        },
        {
            "_id": "5bf4cd32ef051e0768cf6be7",
            "Title": "Vue使用富文本编辑器",
            "Summary": "本人用vue使用富文本编辑器踩了很多坑，特记下供大家借鉴。",
            "Content": "## 一.选取编辑器\n\n刚开始使用的是kindeditor，在npm社区中找到了适用于vue的版本vue-kindeditor。存在如下缺陷：文档不全、网上资料不全、npm社区实例过于简单、上传图片不能控制图片尺寸。\n\n最终换用了wangEditor，优点：文档齐全（有具体vue用法实例）、网上资料多、上传图片可以控制尺寸。\n\n个人推荐wangEditor，官网wangEditor - 轻量级web富文本编辑器\n\n## 二：实例代码\n\n前端vue\n\n    html:\n    <div class=\"ArticleDetail\">\n      <div ref=\"editor\" style=\"text-align:left\"></div>\n    </div>\n\njs:\n\n    <script>\n      import axios from 'axios';\n      import {Loading} from 'element-ui'\n      import E from 'wangeditor'\n      var editor;\n    \n      export default {\n        name: \"WriteArticle\",\n        data: function () {\n          return {\n            Title:'',\n            Content:''\n          }\n        },\n        mounted:function(){\n          var That = this;\n          editor = new E(this.$refs.editor);\n          editor.customConfig = {\n            onchange:function(html){\n              That.Content = html\n            },\n            uploadImgServer: '/api/UploadImg', // 上传图片到服务器\n            uploadFileName : 'Content', //后端使用这个字段获取图片信息\n            uploadImgMaxLength : 1 , // 限制一次最多上传 1 张图片\n          } \n          editor.create()\n        }\n      }\n    </script>\n\n后端node.js\n\n    Express.post('/UploadImg',function (Request,Response) {\n      var From = new Formidable.IncomingForm();\n      //设置保存 文件路径\n      var TargetFile = Path.join(__dirname, './Public/');\n      From.uploadDir = TargetFile;\n    \n      From.parse(Request, function (err, fields, files) {\n        if (err) throw err;\n        var FilePath = files.Content.path;    //此content由前端uploadFileName设置\n        var NewPath = Path.join(Path.dirname(FilePath), files.Content.name);\n        FS.rename(FilePath, NewPath, function (err) {\n          if (err) throw err;\n          var MyJson = {\n            errno: 0,\n            data:['http://localhost:8888/' + files.Content.name]\n          };\n          Response.json(MyJson);\n        });\n      });\n    });\n\n## 三：代码高亮\n\n用了wangEditor才发现，3.0版的不支持代码高亮。可是我的应用场景是我的博客，必须要有代码高亮功能，无奈换掉编辑器。\n\n经过一番对比又选了一个叫mavon-editor的基于vue实现的MakeDown编辑器。好处是使用真滴方便，而且可以与别的MarkDown编辑器实现直接复制文本。Github地址如下hinesboy/mavonEditor，按文档操作即可\n\n需要注意的地方是一般使用富文本的都是管理端，客户端拿到MarkDown格式的数据需要使用maked组件转成html格式的数据来展示。客户端还需要引用一个样式如下\n\n    <link href=\"https://cdn.bootcss.com/github-markdown-css/2.10.0/github-markdown.min.css\" rel=\"stylesheet\">\n\n还需要在展示数据的容器上加上一个class，如：\n\n    <div class=\"markdown-body\" v-html=\"Article.Content\">{{ Article.Content }}</div>\n## 四：使用效果\n我的博客管理端文章管理页面就用的wangEditor：[网站使用效果链接](http://39.104.22.73:68/#/)\n\n![](https://pic1.zhimg.com/v2-523cbbbe8fe4b21c17cdadb67effdfb0_b.png)\n",
            "CreateDate": "2018-11-21T03:12:28.963Z",
            "ArticleTag": "试验田",
            "ArticleCover": "http://39.104.22.73:8888/markdown.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0Mjc2OTkxMywiZXhwIjozNjAwfQ==.IICifNT2d8oqVhta4HYGucX6qn+PPXgd6QyfD0DY2XE=",
            "CommentNum": 7,
            "order": "6",
            "articleReadNum": 817
        },
        {
            "_id": "5beaab072295cf1278e21db3",
            "Title": "对我的第一印象",
            "Summary": "由于自己写的博客，所以可能不好的地方看的时间久了就不知道哪里不好看了。求告诉我你的初见感受",
            "Content": "前段时间网上流行：不知妻美刘强东，哈哈，确实有些东西看的多了顺眼了，就不知道好看在哪，不好看在哪。\n\n由于在写代码时会一遍遍的调试页面，所以看的多了，我不知道页面有哪些地方不协调，或者说很丑。\n\n求只如初见的你，告诉我对博客的第一印象，谢谢啦",
            "CreateDate": "2018-11-13T10:41:59.848Z",
            "ArticleTag": "征求意见",
            "ArticleCover": "http://39.104.22.73:8888/comment.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MjEwNDczOSwiZXhwIjozNjAwfQ==.Z5jfRoHY42oqbR2O8RwFVjBDd5aD1LEZZ4MR+ko/bsA=",
            "CommentNum": 6,
            "articleReadNum": 111
        },
        {
            "_id": "5be7c790fb7a4011d4758aba",
            "Title": "分页器(Vue.js)",
            "Summary": "会涉及父组件与子组件的数据通讯",
            "Content": "![20181107204529481.jpg.png](http://www.sunq.xyz:8888/20181107204529481.jpg.png)\n写了一个简单的分页器，就我博客上用的那个，Vue.js实现的PC端使用的，如上图。\n自己凭空想的，也不知道合不合理，有机会看看别人怎么实现的。我的思路是：\n\n首先分页肯定要写成一个组件，而且分页组件要放在一个个的列表页面组件中。这样的话页面组件就是父组件，分页器是子组件，会涉及父组件与子组件的数据通讯。\n\n## 一：两者分工\n\n父组件初始化分页器，这需要父组件给分页器传递控制显隐的参数、总数据量以及每页展示的条数。子组件中根据这些参数渲染出基本的样式。\n\n分页器在被点击后，比如点击了某一页或者点击了上一页，需要传递当前页给父组件。父组件根据接收到的当前页码，请求数据刷新列表。分页器的高亮切换、上一页及下一个样式切换都在分页器内部实现。\n\n## 二：分页器组件代码\n\n    <template>\n        <div class=\"Pagination\" v-show=\"Pagination\">\n            <div :class=\"PageActive==0 ? 'PageNext PageNextEnable' : 'PageNext'\" @click=\"SelectPage(PageActive-1)\">上一页</div>\n            <div :class=\"PageActive== index ? 'PageNum PageActive' : 'PageNum'\" v-for=\"(item,index) in PageNum\" @click=\"SelectPage(index)\">{{ index+1 }}</div>\n            <div :class=\"PageActive+1 == PageNum ? 'PageNext PageNextEnable' : 'PageNext'\" @click=\"SelectPage(PageActive+1)\">下一页</div>\n            <div class=\"PageTotalNum\">共{{PageTotalNum}}条</div>\n        </div>\n    </template>\n    \n    <script>\n      export default {\n        name: \"Pagination\",\n        data:function () {\n          return{\n            // 当前选中页数\n            PageActive:0\n          }\n        },\n        methods: {\n          // 选择分页\n          SelectPage:function (SelectPage) {\n            var That = this;\n            if(SelectPage > -1 && SelectPage < this.PageNum){\n    \n              That.PageActive = SelectPage;\n              That.$emit('PaginationToParent',SelectPage);\n            }\n          }\n        },\n        props:['Pagination','PageTotalNum','PageNum']\n      }\n    </script>\n\n## 三：列表页使用分页器\n\nhtml代码\n\n    <Pagination v-bind:Pagination=this.Pagination\n                v-bind:PageTotalNum=this.PageTotalNum\n                v-bind:PageNum=this.PageNum\n                v-on:PaginationToParent=\"ValueByPagition\"\n    ></Pagination>\n\n假如列表页每页展示16条数据，那初始化页面时第一次先请求17条数据。判断得到的数据数量，如果小于等于16条就不渲染分页器了，如果大于16条就渲染分页器。下面是初始化分页器：\n\n    // 显示分页器\n    That.Pagination = true;\n    //需获取数据总条数\n    That.PageTotalNum = data;\n    //显示页码按钮使用\n    That.PageNum = Math.ceil(data / 16);\n\n接收分页器传递过来的当前页码，并请求数据，渲染列表\n\n    methods:{\n      ValueByPagition : function (SelectPage) {\n        var That = this;\n          this.SQFrontAjax({\n            Url: '/api/FriendUrlRead/foreend',\n            UploadData: {\n            params: {\n            PagnationData: {\n              Skip:SelectPage * 16,\n              Limit:16\n            }\n          }\n        },\n        Success: function (data) {\n          //渲染列表\n          That.FriendsUrlList = data;\n        }\n      });\n    }\n\n## 四：Vue中父子组件传值语法\n\n1.父组件向子组件传值\n\n父组件在摸板中，像使用自定义标签调用子组件时，将变量放在子组件上，这样自动就传给子组件内部了。\n\n    <Pagination v-bind:Pagination=this.Pagination\n                 v-bind:PageTotalNum=this.PageTotalNum             \n                 v-bind:PageNum=this.PageNum>\n    </Pagination>\n\n子组件内部需要声明props参数，并且这些参数就不用声明直接在模板中使用了。\n\n    export default {\n      props:['Pagination','PageTotalNum','PageNum']\n    }\n\n2.子组件给父组件传值\n\n子组件发送：\n\n    That.$emit('PaginationToParent',SelectPage);\n\n父组件接收：\n\n首先摸板中调用子组件时，绑定v-on方法，与子组件发送的第一个参数一致。\n\n    <Pagination v-on:PaginationToParent=\"ValueByPagition\" ></Pagination>\n\n并且什么ValueByPagition方法，这个方法接受的参数就是子组件$emit方法中第二个参数\n\n    methods:{   \n      ValueByPagition :function(SelectPage){\n        console.log(SelectPage);//此变量就是子组件$emit方法中第二个参数\n      }\n    }\n# 五：父组件操作子组件方法\n子组件中，定义方法：\n```\nexport default {\n    name: \"Pagination\",\n    methods: {\n      SwitchPagin:function (bool) {\n        this.Pagination = bool;\n        this.PageActive = 0;\n      }\n    }\n}\n```\n\n\n\n父组件中，直接根据ref定位，调用方法即可：\n```\n<Pagination ref=\"Pagination\"></Pagination >\n\nThat.$refs.Pagination.SwitchPagin(true);\n```\n\n\n\n",
            "CreateDate": "2018-11-08",
            "ArticleTag": "技术笔记",
            "ArticleCover": "http://39.104.22.73:8888/skippage.jpeg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MTkxNjE4MSwiZXhwIjozNjAwfQ==.19Pu92A6IvjUK96/x2uIlXsyR2IAiToQpSQRefM6xhQ=",
            "CommentNum": 0,
            "articleReadNum": 73
        },
        {
            "_id": "5bdc0663c7a7990ffcd4071a",
            "Title": "CSS3动画",
            "Summary": "Vue自己实现弹框动画",
            "Content": "用惯了UI框架的弹框，发现自己写的弹框没有动画是真的别扭。自己动手添加动画时，发现在关闭弹框时，不知道如何实现一个打开弹框的逆执行效果？\n\n想到应该需要切换Dom的类，怀疑应该有可以不切换实现的方法。网上搜了搜发现别人也是用切换类来实现。就放弃了，自己也切换类来实现。一个类控制显示动画，另一个类逆执行显示动画。\n\n因为用的vue不能直接操作Dom，我的思路是设置两个变量，一个用来控制弹框显隐（Wrapper），一个用来控制类名切换（FadeAnimate）。\n\n前端样式如下：\n\n    <div :class=\"FadeAnimate ? 'FriendUrlCreateWindowFadeIn' : 'FriendUrlCreateWindowFadeOut'\" v-show=\"Wrapper\"></div>  \n\n\n    .FriendUrlCreateWindowFadeIn{\n        animation: FadeIn 0.2s linear;\n    }\n    .FriendUrlCreateWindowFadeOut{\n        animation: FadeOut 0.2s linear;\n    }\n    \n    @keyframes FadeIn{\n        0% {transform: scale(0.9)}\n        20% {transform:scale(0.925)}\n        60% {transform:scale(0.95)}\n        80% {transform:scale(0.975)}\n        100% {transform:scale(1)}\n    }\n    \n    @keyframes FadeOut{\n        0% {transform: scale(1)}\n        20% {transform:scale(0.975)}\n        60% {transform:scale(0.95)}\n        80% {transform:scale(0.925)}\n        100% {transform:scale(0.9)}\n    }\n\n打开（显示）弹框时没有什么别的操作，就设置两个变量为true即可：\n\n    this.Wrapper = true;\n    this.FadeAnimate = true;\n\n\n关闭弹框时需要先设置类名切换变量，然后延时等动画执行完毕，再关闭弹框\n\n    var That = this;\n    this.FadeAnimate = false;\n    setTimeout(function () {\n        That.Wrapper = false;\n    },200)\n",
            "CreateDate": "2018-11-02T08:07:01.658Z",
            "ArticleTag": "技术笔记",
            "ArticleCover": "http://39.104.22.73:8888/css3.png",
            "CommentNum": 3,
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MTE0NTk2NCwiZXhwIjozNjAwfQ==.Kyzph9Eyhm51kpLGXlufiakc+jGIACN/iLtk4XyVwx4=",
            "articleReadNum": 133
        },
        {
            "_id": "5bd9624b00010812a8a0a451",
            "Title": "OPTIONS请求",
            "Summary": "自定义请求会引起OPTIONS请求，又叫预请求，需要在服务器端设置响应头。",
            "Content": "<p>有时我们在浏览器中发现发送的ajax请求自动请求两次，第一次是options请求，第二次才是你自己发送的get或post请求。</p><p>有时我们也会发现，自己用的get或者post方法请求的，浏览器只有一个options请求。自己的get或post请求却没有。因为options请求即预请求没有通过，所以后面的get或post请求就不会建立。</p><p>这是因为你在header请求头里也传了参数，即传说中的设置了<b>自定义的请求头。这时就需要在服务器端设置响应头：</b></p><div><pre><code>Access-Control-Allow-Headers:字段1,字段2\n</code></pre></div><p>字段1，字段2，分别对应你header中上传的字段。当然如果只有一个就只写一个，有多个就写多个，并用逗号分隔。</p>",
            "CreateDate": "2018-10-31T08:03:45.993Z",
            "ArticleTag": "技术笔记",
            "ArticleCover": "",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MDk3Mjk5MywiZXhwIjozNjAwfQ==.+QISXz94u2cGJvp5+Ge3DiBrPF9jy+mWN9+YhISK0nQ=",
            "CommentNum": 0,
            "articleReadNum": 50
        },
        {
            "_id": "5bd59bfcb3686b0f004644a7",
            "Title": "关于人生",
            "Summary": "哈哈，自己关于人生的一点小领悟吧",
            "Content": "###### 2018-10-28 上海\n<p>虽然本人是个理科男，但有时也会想人生到底是什么？</p>\n<p>说来挺不好意思，我已经过了两个本命年了，毕业也一年半了。熬过了刚毕业时的懵懂迷茫、年少轻狂、急功近利、充满梦想。本以为将会不再迷茫，可谁想到在一段时间的规律生活后，还是会恍恍惚惚觉得生活好没意思，什么事情都不想干。</p>\n<p>经过这一两年的社会经历，慢慢的才觉得生活本来就是无聊的、缓慢的、流逝的。年轻时总觉得不该让生活平平淡淡、一潭死水，就应该折腾点波澜出来。现在才发现可能所有人的人生都是这样，大部分时间都是孤独的、寂静无声的。</p>\n<p>虽然现在我也深知独处时间的合理安排会使人生有很大不同，也会试着在独处时间里做一些积累性的东西。比如学习了、读书了、培养兴趣爱好等。可还是不能很好的控制住自己，不虚度这些自由的时间。经常在无人约束的时间里打游戏、刷视频来空耗掉生命，待时间流过更加空虚和后悔。</p>\n\n###### 2019-03-21 郑州\n<p>最终还是没能按耐住自己躁动的心，我从上海的公司离职了。跟着亲戚做了水果连锁生意，也算是出来创业了。我用半年时间从店员干到店长，又从半年时间从一个店的店长干到管理6家点。</p>\n<p>管理6家店的另外一年半里，我曾带起2家店的业绩，刷新2家店的历史盈利记录，到亲手操办转掉这6家店，最终宣告创业失败。</p>\n\n###### 2021-08-09 郑州\n<p>2021年5月20号又找了一份前端工作，重操旧业。现在心里踏实了，不再浮躁，只想踏踏实实学技术，踏踏实实挣工资养家</p>\n",
            "CreateDate": "2018-10-28T11:04:43.484Z",
            "ArticleTag": "成长感悟",
            "ArticleCover": "http://39.104.22.73:8888/mylife.jpg",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTU0MDcyNDUyNSwiZXhwIjozNjAwfQ==.9q+oFOnSBgIUkAyUHqe6Hob1FNT06dcemAWtdyRsuEw=",
            "CommentNum": 5,
            "articleReadNum": 267
        },
        {
            "_id": "5bbdd9aeeef35d22ec0cf87c",
            "Title": "关于本博客",
            "Summary": "小博客的基本介绍",
            "Content": "<p>作为一个前端程序猿一直有一个愿望，就是拥有一个自己的小网站。经过好几个周末的摸索，终于有了这个雏形。</p>\n\n### 一：博客组成\n\n<p>这个博客由用户端，管理端，服务端组成。详细如下：<br></p>\n<blockquote>\n<p>用户端：自己UI组件 + vue.js</p>\n<p>管理端：ElementUI + vue.js</p>\n<p>服务端：Node.js + express + Mongodb</p>\n<p>服务器：Linux<br></p>\n<p>代码托管：https://github.com/SunQQQ<br></p>\n</blockquote>\n\n博客管理端已向用户开放，使用公开的账号密码可以查看所有功能。\n\n博客访问量，用户轨迹等信息也与大家共享。有兴趣可以咨询我所有技术细节的代码实现，欢迎大家与我交流。\n\n博客所有代码开源，GitHub源码地址为：[传送门](https://github.com/SunQQQ)\n\n具体功能请点击各个菜单查看。\n### 二：网站特点\n\n```\n1、本博客不强制游客注册/登录，留言、评论等功能只需填入昵称，即可使用。\n\n2、博客对外开放管理后台、流量数据、所有源码等，分享技术，毫无保留。\n\n3、博客用户端、管理后台、后端接口、UI设计、服务器部署全部由一人维护。持续优化，随时更新。\n\n4、已实现异常处理、公共工具类、各种父子组件、数据缓存、防抖节流、用户轨迹、首屏优化等功能。\n\n5、别的我想到了再来夸自己。这里跪求您的Github一赞，谢谢您对博客开发者的支持！\n\n```\n### 三：博客合作\n本博客接广告合作，费用实惠。或者有前端兼职需求，也可与我联系",
            "CreateDate": "2018-10-15",
            "ArticleTag": "技术笔记",
            "Token": "eyJkYXRhIjp7fSwiY3JlYXRlZCI6MTUzOTE2ODM5MCwiZXhwIjozNjAwfQ==.sVAJWe8zHIlx7KR7rgt8x8llAQvZz7fwwD8gXZnlQ50=",
            "ArticleCover": "http://39.104.22.73:8888/aboutMe.jpg",
            "CommentNum": 7,
            "articleReadNum": 448,
            "order": null
        }
    ]
}